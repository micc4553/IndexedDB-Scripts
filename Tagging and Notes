// ==UserScript==
// @name         AO3 Tagging and Notes
// @version      8.3.5-indexeddb
// @description  Tag AO3 works with Google sync for cross-device data
// @match        https://archiveofourown.org/*
// @icon         https://archiveofourown.org/favicon.ico
// @updateURL    https://raw.githubusercontent.com/micc4553/AO3-Scripts/refs/heads/main/Tagging%20and%20Notes
// @downloadURL  https://raw.githubusercontent.com/micc4553/AO3-Scripts/refs/heads/main/Tagging%20and%20Notes
// @grant        GM_xmlhttpRequest
// ==/UserScript==

(function () {
    "use strict";

    // Constants
    const KEYS = {
        LABELS: "ao3_fic_labels",
        NOTES: "ao3_fic_notes",
        AUTHOR_NOTES: "ao3_author_notes",
        DELETED_AUTHOR_NOTES: "ao3_deleted_author_notes",
        DELETED_NOTES: "ao3_deleted_notes",
        LAST_DOWNLOAD: "ao3_last_download",
        DOWNLOADED_WORKS: "ao3_downloaded_works",
        METADATA_CACHE: "ao3_metadata_cache"
    };

const PRESET_TAGS = ["Finished", "To Read", "Not Interested", "Dropped", "Disliked", "Liked", "Favourite", "Dish"];

    const COLLAPSE_TAGS = ["Finished", "Not Interested", "Dropped", "Disliked"];
    const BORDER_TAGS = ["To Read", "Liked", "Favourite", "Dish"];

const TAG_CONFIG = {
    "Finished": { bg: "#8b7db8", text: "#fff" },
    "To Read": { bg: "#6b8a7a", text: "#fff" },
    "Not Interested": { bg: "#6e6a86", text: "#fff" },
    "Dropped": { bg: "#7a9bb8", text: "#fff" },
    "Disliked": { bg: "#8b7355", text: "#fff" },
    "Liked": { bg: "#cbb974", text: "#fff" },
    "Favourite": { bg: "#d6a5c9", text: "#fff" },
    "Dish": { bg: "#a85c6b", text: "#fff" }
};

// Derive other objects from TAG_CONFIG
const TAG_COLORS = Object.fromEntries(
    Object.entries(TAG_CONFIG).map(([tag, config]) => [tag, { bg: config.bg, text: config.text }])
);

    // Utility Functions - Consolidated
    // --- START REPLACEMENT: localStorage to IndexedDB ---
    class IndexedDBStorage {
        constructor(dbName, storeName) {
            this.dbName = dbName;
            this.storeName = storeName;
            this.db = null;
            this.cache = {}; // In-memory cache for synchronous access
        }

        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.dbName, 1);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(this.storeName)) {
                        db.createObjectStore(this.storeName, { keyPath: 'key' });
                    }
                };

                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log("Database initialized successfully");
                    // Pre-load all data into the cache for synchronous access later
                    this.loadAllToCache().then(resolve).catch(reject);
                };

                request.onerror = (event) => {
                    console.error("Database error:", event.target.errorCode);
                    reject(event.target.error);
                };
            });
        }

        async loadAllToCache() {
            return new Promise((resolve, reject) => {
                if (!this.db) return reject("Database not initialized");

                const transaction = this.db.transaction(this.storeName, 'readonly');
                const store = transaction.objectStore(this.storeName);
                const request = store.getAll();

                request.onsuccess = (event) => {
                    const allData = event.target.result;
                    this.cache = {}; // Clear existing cache
                    allData.forEach(item => {
                        this.cache[item.key] = item.value;
                    });
                    console.log("All data loaded into cache.");
                    resolve();
                };

                request.onerror = (event) => {
                    console.error("Error loading all data:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // This method remains SYNCHRONOUS, reading from the pre-loaded cache
        load(key, fallback = {}) {
            const cachedValue = this.cache[key];
            if (cachedValue !== undefined) {
                // Return a deep copy to prevent direct mutation of the cache, mimicking JSON.parse behavior
                try {
                    return JSON.parse(JSON.stringify(cachedValue));
                } catch {
                    return fallback;
                }
            }

            return fallback;
        }

        save(key, value) {
            this.cache[key] = value;

            if (!this.db) {
                console.error("Database not initialized, cannot save.");
                return;
            }

            const transaction = this.db.transaction(this.storeName, 'readwrite');
            const store = transaction.objectStore(this.storeName);
            const request = store.put({ key, value });

            request.onerror = (event) => {
                console.error(`Error saving data for key "${key}":`, event.target.error);
            };
        }

        loadLabels() { return this.load(KEYS.LABELS); }
        saveLabels(v) { this.save(KEYS.LABELS, v); }
        loadNotes() { return this.load(KEYS.NOTES); }
        saveNotes(v) { this.save(KEYS.NOTES, v); }
        loadAuthorNotes() { return this.load(KEYS.AUTHOR_NOTES); }
        saveAuthorNotes(v) { this.save(KEYS.AUTHOR_NOTES, v); }
        loadDownloadHistory() { return this.load(KEYS.DOWNLOADED_WORKS); }
        saveDownloadHistory(v) { this.save(KEYS.DOWNLOADED_WORKS, v); }
        loadMetadataCache() { return this.load(KEYS.METADATA_CACHE); }
        saveMetadataCache(v) { this.save(KEYS.METADATA_CACHE, v); }
        loadDeletedAuthorNotes() { return this.load(KEYS.DELETED_AUTHOR_NOTES, {}); }
        saveDeletedAuthorNotes(v) { this.save(KEYS.DELETED_AUTHOR_NOTES, v); }
        loadDeletedNotes() { return this.load(KEYS.DELETED_NOTES, {}); }
        saveDeletedNotes(v) { this.save(KEYS.DELETED_NOTES, v); }
    }

    const Storage = new IndexedDBStorage('AO3DB', 'data');

    const UI = {
        formatDateTime: (d) => d.toLocaleString('en-US', {
            year: "numeric", month: "short", day: "numeric",
            hour: "2-digit", minute: "2-digit", hour12: true
        }),

        createButton(text, styles = {}, onclick = null) {
            const btn = document.createElement("button");
            btn.textContent = text;
            Object.assign(btn.style, {
                padding: "6px 12px",
                border: "none",
                borderRadius: "4px",
                cursor: "pointer",
                ...styles
            });
            if (onclick) btn.addEventListener("click", onclick);
            return btn;
        },

        createModal(content, title = "") {
            const modal = document.createElement("div");
            modal.innerHTML = `
                <div class="backdrop" style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:100000;display:flex;align-items:center;justify-content:center;">
                    <div class="modal-content" style="background:#232136CC;color:#fff;padding:20px;border-radius:8px;max-width:90%;max-height:80%;border:1px solid #ddd;overflow-y:auto;">
                        ${title ? `<h3 style="margin-top:0;color:#fff;">${title}</h3>` : ""}
                        ${content}
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Close on backdrop click only
            modal.addEventListener("click", (e) => {
                if (e.target.classList.contains('backdrop')) {
                    modal.remove();
                }
            });

            return modal;
        }
    };

  function normalizeWorkId(input) {
    if (typeof input === 'string') {
        let cleaned = input.replace("bookmark_", "");
        const match = cleaned.match(/(\d+)/);
        return match ? match[1] : null;
    }
    return null;
}

    // Inject global styles once
function injectGlobalStyles() {
    if (document.getElementById('ao3-global-styles')) return;

    const style = document.createElement("style");
    style.id = 'ao3-global-styles';
    style.textContent = `
.fic-item {
    transition: border 0.2s, box-shadow 0.2s;
    border-left: 4px solid #666 !important;
    box-sizing: border-box;
}
.fic-item.selected {
    border-left: 4px solid #c4a7e7 !important;
    box-shadow: 0 0 0 1px #c4a7e7;
}

.work-collapsed .work-toggle {
    cursor: pointer;
    position: relative;
}

.work-expanded .work-toggle {
    cursor: pointer;
    position: relative;
}

.work-collapsed .collapsible-content {
    display: none !important;
}

.work-expanded .collapsible-content {
    display: block !important;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
    `;
    document.head.appendChild(style);
}
    class TagBrowserEventManager {
        constructor(modal) {
            this.modal = modal;
            this.content = modal.querySelector("#tag-browser-content");
            this.currentSort = 'work-id';
            this.currentTag = null;
            this.workData = [];
            this.authorsData = [];
            this.setupEventDelegation();
        }

        setupEventDelegation() {
            this.content.addEventListener("click", this.handleContentClick.bind(this));
            this.content.addEventListener("mouseenter", this.handleMouseEnter.bind(this), true);
            this.content.addEventListener("mouseleave", this.handleMouseLeave.bind(this), true);
        }

        handleContentClick(e) {
            const target = e.target;

            if (target.matches(".delete-tag-btn")) {
                e.stopPropagation();
                this.handleDeleteTag(target);
            }

            else if (target.matches(".delete-author-note-btn")) {
                e.stopPropagation();
                this.handleDeleteAuthorNote(target);
            }

else if (target.matches(".refresh-fic-btn") || target.closest(".refresh-fic-btn")) {
    e.stopPropagation();
    const button = target.closest(".refresh-fic-btn") || target;
    this.handleRefreshFic(button);
}

if (target.matches(".download-tag-btn") || target.closest(".download-tag-btn")) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
    const button = target.closest(".download-tag-btn") || target;
    const tag = button.dataset.tag;
    this.handleDownloadTag(tag);
    return;
}
            else if (target.closest(".tag-item")) {
                e.stopPropagation();
                const tagItem = target.closest(".tag-item");
                const tag = tagItem.dataset.tag;
                if (tag) this.handleTagClick(tag);
            }

            else if (target.closest(".author-notes-item")) {
                e.stopPropagation();
                this.handleAuthorNotesClick();
            }

            else if (target.matches("#back-to-tags")) {
                e.preventDefault();
                e.stopPropagation();
                this.handleBackToTags();
            }

            else if (target.matches("#sort-work-id")) {
                this.handleSortWorkId();
            }
            else if (target.matches("#sort-title")) {
                this.handleSortTitle();
            }
            else if (target.matches("#sort-author-date")) {
                this.handleSortAuthorDate();
            }
            else if (target.matches("#sort-author-name")) {
                this.handleSortAuthorName();
            }

            else if (target.matches("#refresh-metadata")) {
                this.handleRefreshMetadata(target);
            }

            else if (target.closest(".fic-item")) {
                const ficItem = target.closest(".fic-item");
                const checkbox = ficItem.querySelector('.work-checkbox');
                if (checkbox && target !== checkbox) {
                    checkbox.checked = !checkbox.checked;
                    ficItem.classList.toggle('selected', checkbox.checked);
                    this.updateSelectedCount();
                }
            }
        }

        handleMouseEnter(e) {
            const target = e.target;

            if (target.matches(".delete-tag-btn") || target.matches(".delete-author-note-btn")) {
                target.style.background = "#d32f2f";
                target.style.transform = "scale(1.1)";
            }

            else if (target.matches(".refresh-fic-btn")) {
                target.style.transform = "scale(1.2)";
            }

            else if (target.closest(".tag-item")) {
                const tagItem = target.closest(".tag-item");
                const tag = tagItem.dataset.tag;
                const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };
                tagItem.style.background = "#232136CC";
                tagItem.style.transform = "translateY(-1px)";
                tagItem.style.boxShadow = `0 0 12px 3px ${color.bg}77`;
            }

            else if (target.closest(".author-notes-item")) {
                const item = target.closest(".author-notes-item");
                item.style.background = "#232136CC";
                item.style.transform = "translateY(-1px)";
                item.style.boxShadow = "0 0 12px 3px #e5988877";
            }
        }

        handleMouseLeave(e) {
            const target = e.target;

            if (target.matches(".delete-tag-btn") || target.matches(".delete-author-note-btn")) {
                target.style.background = "#f44336";
                target.style.transform = "scale(1)";
            }

            else if (target.matches(".refresh-fic-btn")) {
                target.style.transform = "scale(1)";
            }

            else if (target.closest(".tag-item")) {
                const tagItem = target.closest(".tag-item");
                const tag = tagItem.dataset.tag;
                const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };
                tagItem.style.background = "#44415a40";
                tagItem.style.transform = "";
                tagItem.style.boxShadow = `0 0 8px 2px ${color.bg}55`;
            }

            else if (target.closest(".author-notes-item")) {
                const item = target.closest(".author-notes-item");
                item.style.background = "#44415a40";
                item.style.transform = "";
                item.style.boxShadow = "0 0 8px 2px #e5988855";
            }
        }

        handleDeleteTag(button) {
            const ficId = button.dataset.ficId;
            const tagToRemove = button.dataset.tag;

            if (!confirm(`Remove "${tagToRemove}" tag from this story?`)) return;

            const labels = Storage.loadLabels();
            if (labels[ficId] === tagToRemove) {
                delete labels[ficId];
                Storage.saveLabels(labels);

                const workItem = button.closest(".work-item");
                workItem.style.transition = "opacity 0.3s, transform 0.3s";
                workItem.style.opacity = "0";
                workItem.style.transform = "translateX(20px)";

                setTimeout(() => {
                    workItem.remove();
                    const remainingWorks = Object.keys(Storage.loadLabels())
                        .filter(id => Storage.loadLabels()[id] === tagToRemove);
                    if (remainingWorks.length === 0) {
                        this.handleBackToTags();
                    }
                }, 300);
            }
        }

        handleDeleteAuthorNote(button) {
            const authorId = button.dataset.authorId;

            if (!confirm(`Delete note for author "${authorId}"?`)) return;

            const authorNotes = Storage.loadAuthorNotes();
            const deletedAuthorNotes = Storage.loadDeletedAuthorNotes();

            deletedAuthorNotes[authorId] = Date.now();

            Storage.saveDeletedAuthorNotes(deletedAuthorNotes);

            delete authorNotes[authorId];
            Storage.saveAuthorNotes(authorNotes);

            const noteItem = button.closest(".author-note-item");
            if (noteItem) {
                noteItem.style.transition = "opacity 0.3s, transform 0.3s";
                noteItem.style.opacity = "0";
                noteItem.style.transform = "translateX(20px)";

                setTimeout(() => {
                    noteItem.remove();
                    const remainingNotes = Object.keys(Storage.loadAuthorNotes());
                    if (remainingNotes.length === 0) {
                        this.handleBackToTags();
                    }
                }, 300);
            }
        }

async handleRefreshFic(button) {
    const workId = button.dataset.workId;
    button.innerHTML = "✅";
    button.disabled = true;

    try {
        const cache = Storage.loadMetadataCache();
        delete cache[workId];
        Storage.saveMetadataCache(cache);

        const newMetadata = await MetadataCache.fetchWorkMetadata(workId, false);

        const workItem = button.closest('.work-item');
        const authorLink = workItem.querySelector('a');

        authorLink.innerHTML = `<strong>${newMetadata.title}</strong> by ${newMetadata.author}`;

        console.log("Updated to:", newMetadata.title, "by", newMetadata.author);

        setTimeout(() => {
            button.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
            </svg>`;
            button.disabled = false;
            button.title = "";
        }, 1000);

    } catch (error) {
        console.error("Failed to refresh metadata:", error);
        button.innerHTML = "❌";

        if (error.message.includes('429') || error.message.includes('rate limit')) {
            button.title = "Rate limited - try again later";
            setTimeout(() => {
                button.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
                </svg>`;
                button.disabled = false;
                button.title = "";
            }, 10000);
        } else if (error.message.includes('403') || error.message.includes('404')) {
            button.title = "Work unavailable - cannot refresh";
            button.disabled = true;
        } else {
            button.title = "Refresh failed - click to retry";
            setTimeout(() => {
                button.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
                </svg>`;
                button.disabled = false;
                button.title = "";
            }, 3000);
        }
    }
}
        async handleTagClick(tag) {
            this.currentTag = tag;
            await this.showWorksForTag(tag);
        }

        handleAuthorNotesClick() {
            this.showAuthorNotes();
        }

        async handleDownloadTag(tag) {
            await downloadManager.downloadTaggedWorks(tag);
        }

        handleBackToTags() {
            this.renderMainTagsView();
        }

        handleSortWorkId() {
            this.currentSort = 'work-id';
            this.sortWorkData('work-id');
            this.updateWorksDisplay();
            this.updateSortButtons();
        }

        handleSortTitle() {
            this.currentSort = 'title';
            this.sortWorkData('title');
            this.updateWorksDisplay();
            this.updateSortButtons();
        }

        handleSortAuthorDate() {
            this.currentSort = 'author-date';
            this.sortAuthorData('date');
            this.updateAuthorDisplay();
            this.updateAuthorSortButtons();
        }

        handleSortAuthorName() {
            this.currentSort = 'author-name';
            this.sortAuthorData('name');
            this.updateAuthorDisplay();
            this.updateAuthorSortButtons();
        }

        async handleRefreshMetadata(button) {
            button.textContent = "🔄 Refreshing...";
            button.disabled = true;

            try {
                await MetadataCache.refreshMetadataForTag(this.currentTag);
                await this.showWorksForTag(this.currentTag);
            } catch (error) {
                console.error("Error refreshing metadata:", error);
                alert("Error refreshing metadata. Check console for details.");
            }

            button.textContent = "🔄 Refresh Titles";
            button.disabled = false;
        }

        sortWorkData(sortType) {
            if (sortType === 'title') {
                this.workData.sort((a, b) => a.metadata.title.localeCompare(b.metadata.title));
            } else {
                // Sort by Work ID (newest first)
                this.workData.sort((a, b) => {
                    let aId = parseInt(a.workId);
                    let bId = parseInt(b.workId);

                    if (isNaN(aId)) {
                        const aMatch = a.ficId.match(/\d+/);
                        aId = aMatch ? parseInt(aMatch[0]) : 0;
                    }

                    if (isNaN(bId)) {
                        const bMatch = b.ficId.match(/\d+/);
                        bId = bMatch ? parseInt(bMatch[0]) : 0;
                    }

                    return bId - aId;
                });
            }
        }

        sortAuthorData(sortType) {
            if (sortType === 'name') {
                this.authorsData.sort((a, b) => a.authorId.localeCompare(b.authorId));
            } else {
                this.authorsData.sort((a, b) => {
                    const aDate = Date.parse(a.note.date) || 0;
                    const bDate = Date.parse(b.note.date) || 0;
                    return bDate - aDate;
                });
            }
        }

        updateSortButtons() {
            const sortWorkIDBtn = this.content.querySelector("#sort-work-id");
            const sortTitleBtn = this.content.querySelector("#sort-title");
            const color = TAG_COLORS[this.currentTag] || { bg: "#6e6a86", text: "#fff" };

            [sortWorkIDBtn, sortTitleBtn].forEach(btn => {
                if (btn) {
                    btn.style.background = '#555';
                    btn.style.color = 'white';
                    btn.style.boxShadow = 'none';
                }
            });

            let activeBtn = this.currentSort === 'work-id' ? sortWorkIDBtn : sortTitleBtn;
            if (activeBtn) {
                activeBtn.style.background = color.bg;
                activeBtn.style.color = color.text;
                activeBtn.style.boxShadow = `0 0 8px 2px ${color.bg}55`;
            }
        }

        updateAuthorSortButtons() {
            const dateBtn = this.content.querySelector('#sort-author-date');
            const nameBtn = this.content.querySelector('#sort-author-name');

            [dateBtn, nameBtn].forEach(btn => {
                if (btn) {
                    btn.style.background = '#555';
                    btn.style.color = 'white';
                    btn.style.boxShadow = 'none';
                }
            });

            const activeBtn = this.currentSort === 'author-date' ? dateBtn : nameBtn;
            if (activeBtn) {
                activeBtn.style.background = '#e59888';
                activeBtn.style.color = '#fff';
                activeBtn.style.boxShadow = '0 0 8px 2px #e5988855';
            }
        }

updateWorksDisplay() {
        const color = TAG_COLORS[this.currentTag] || { bg: "#6e6a86", text: "#fff" };
  const worksList = this.workData.map(({ ficId, workId, metadata, note, summary }) => {
        return `
            <div class="work-item" data-fic-id="${ficId}"
                 style="padding:12px 16px;margin:8px 0;border-radius:6px;background:#232136CC;
                        border:1px solid #ddd;position:relative;">
                <div style="margin-bottom:8px;">
                    <a href="https://archiveofourown.org/works/${workId}" target="_blank" style="text-decoration:none;">
                        <strong>${metadata.title}</strong> by ${metadata.author}
                    </a>
                    <button class="refresh-fic-btn" data-fic-id="${ficId}" data-work-id="${workId}"
                            style="background:transparent;color:#ccc;border:none;cursor:pointer;margin-left:8px;box-shadow:none;padding:0;outline:none;position:relative;top:-15px;height:0;overflow:visible;transform-origin:center center;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.2"/>
                        </svg>
                    </button>
                </div>
                ${this.currentTag === "To Read" && summary ? `
                    <div style="font-size:0.85em;margin:8px 0;padding:8px;background:#44415a20;border-radius:4px;">
                        <strong>Summary:</strong> ${summary}
                    </div>
                ` : ""}
                ${note ? `
                    <div style="font-size:16px;margin-top:6px;padding:8px;background:#44415a40;border-radius:4px;border-left:4px solid">
                        "${note.text}"
                        ${note.date ? `<div style="font-size:0.8em;margin-top:4px;color:#999;">${note.date}</div>` : ""}
                    </div>
                ` : ""}
                <button class="delete-tag-btn" data-fic-id="${ficId}" data-tag="${this.currentTag}"
                        style="position:absolute;top:8px;right:8px;background:#f44336;color:white;
                               border:none;border-radius:4px;width:24px;height:24px;cursor:pointer;
                               font-size:12px;">×</button>
            </div>
        `;
    }).join("");

    const worksListContainer = this.content.querySelector("#works-list");
    if (worksListContainer) {
        worksListContainer.innerHTML = worksList;
    }
}

        updateAuthorDisplay() {
            const authorsList = this.authorsData.map(({authorId, note}) => `
                <div class="author-note-item" data-author-id="${authorId}"
                     style="padding:12px 16px;margin:8px 0;border-radius:6px;background:#232136CC;border:1px solid #ddd;position:relative;">
                    <div style="margin-bottom:8px;">
                        <a href="https://archiveofourown.org/users/${authorId}" target="_blank" style="font-weight:bold;">
                            ${authorId}
                        </a>
                    </div>
                    <div style="font-size:16px;padding:8px;background:#44415a40;border-radius:4px;border-left:3px solid #e59888;">
                        <div style="white-space:pre-wrap;"><em>"${note.text}"</em></div>
                        ${note.date ? `<div style="font-size:0.8em;margin-top:4px;color:#999;">${note.date}</div>` : ""}
                    </div>
                    <button class="delete-author-note-btn" data-author-id="${authorId}"
                            style="position:absolute;top:8px;right:8px;background:#f44336;color:white;border:none;border-radius:4px;width:24px;height:24px;cursor:pointer;font-size:12px;">×</button>
                </div>
            `).join("");

            const authorsListContainer = this.content.querySelector('#authors-list');
            if (authorsListContainer) {
                authorsListContainer.innerHTML = authorsList;
            }
        }

        updateSelectedCount() {
            const checkboxes = this.content.querySelectorAll('.work-checkbox');
            const selectedCount = this.content.querySelector('#selected-count');
            const downloadBtn = this.content.querySelector('#download-selected');

            if (selectedCount && downloadBtn) {
                const selected = Array.from(checkboxes).filter(cb => cb.checked);
                selectedCount.textContent = `${selected.length} selected`;
                downloadBtn.disabled = selected.length === 0;
            }
        }

        // Main view rendering methods
        async showWorksForTag(tag) {
            console.log("showWorksForTag called with:", tag);

            try {
                const labels = Storage.loadLabels();
                const notes = Storage.loadNotes();
                const works = Object.keys(labels).filter(id => labels[id] === tag);

                if (works.length === 0) {
                    this.content.innerHTML = `<div>No works found for tag "${tag}"</div>`;
                    return;
                }

                // Show loading state
                this.content.innerHTML = `
                    <div style="text-align:center;padding:20px;">
                        <div>Loading works for ${tag}...</div>
                        <div style="margin:10px 0;">
                            <div style="display:inline-block;width:30px;height:30px;border:3px solid #f3f3f3;border-top:3px solid #c4a7e7;border-radius:50%;animation:spin 1s linear infinite;"></div>
                        </div>
                    </div>
                `;

                const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#fff" };

this.workData = await Promise.all(
    works.map(async (ficId) => {
        try {
            const workId = normalizeWorkId(ficId);
            const metadata = await MetadataCache.fetchWorkMetadata(workId);

            let summary = '';
            if (tag === "To Read") {
                summary = await fetchWorkSummary(workId);
            }

            return {
                ficId,
                workId,
                metadata,
                note: notes[ficId],
                summary
            };
        } catch (error) {
            console.error("Error fetching metadata for", ficId, error);
            return {
                ficId,
                workId: normalizeWorkId(ficId),
                metadata: { title: `Work ${ficId}`, author: 'Unknown' },
                note: notes[ficId],
                summary: ''
            };
        }
    })
);

                this.sortWorkData('work-id');

                this.content.innerHTML = `
                    <div style="margin-bottom:20px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
                            <button id="back-to-tags" style="background:none;border:1px solid #666;padding:6px 12px;border-radius:4px;cursor:pointer;color:#fff;">
                                ← Back to Tags
                            </button>
                            <div style="display:flex;gap:10px;">
                                <div style="padding:6px 12px;border-radius:4px;font-weight:bold;background:${color.bg};color:${color.text};">
                                    ${tag}
                                </div>
                                <span style="color:#ccc;padding:6px 0;">${works.length} work${works.length === 1 ? "" : "s"}</span>
                            </div>
                        </div>

                        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                            <div style="display:flex;gap:8px;align-items:center;">
                                <span style="color:#ccc;font-size:0.9em;">Sort by:</span>
                                <button id="sort-work-id" style="background:${color.bg};color:${color.text};border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.85em;box-shadow:0 0 8px 2px ${color.bg}55;">Work ID</button>
                                <button id="sort-title" style="background:#555;color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.85em;">Title A-Z</button>
                            </div>
                            <button id="refresh-metadata" style="background:none;border:1px solid #666;padding:4px 8px;border-radius:3px;cursor:pointer;color:#fff;font-size:0.8em;">
                                Refresh Titles
                            </button>
                        </div>
                    </div>
                    <div id="works-list"></div>
                `;

                this.updateWorksDisplay();

            } catch (error) {
                console.error("Error in showWorksForTag:", error);
                this.content.innerHTML = `
                    <div style="color:#f44336;text-align:center;padding:20px;">
                        <div>Error loading works for "${tag}"</div>
                        <div style="font-size:0.9em;margin-top:8px;">Please try again or check the console for details.</div>
                    </div>
                `;
            }
        }

        showAuthorNotes() {
            const authorNotes = Storage.loadAuthorNotes();
            this.authorsData = Object.entries(authorNotes).map(([authorId, note]) => ({ authorId, note }));

            this.sortAuthorData('date');

            this.content.innerHTML = `
                <div style="margin-bottom:20px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
                        <button id="back-to-tags" style="background:none;border:1px solid #666;padding:6px 12px;border-radius:4px;cursor:pointer;color:#fff;">
                            ← Back to Tags
                        </button>
                        <div style="display:flex;align-items:center;gap:10px;">
                            <div style="padding:6px 12px;border-radius:4px;font-weight:bold;background:#e59888;color:#fff;">
                                📝 Author Notes
                            </div>
                            <span style="color:#ccc;">${this.authorsData.length} author${this.authorsData.length === 1 ? "" : "s"}</span>
                        </div>
                    </div>
                    <div style="display:flex;gap:8px;margin-bottom:10px;align-items:center;">
                        <span style="color:#ccc;font-size:0.9em;">Sort by:</span>
                        <button id="sort-author-date" style="background:#e59888;color:#fff;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.85em;box-shadow:0 0 8px 2px #e5988855;">Date Added</button>
                        <button id="sort-author-name" style="background:#555;color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.85em;">Name A-Z</button>
                    </div>
                </div>
                <div id="authors-list"></div>
            `;

            this.updateAuthorDisplay();
        }

        renderMainTagsView() {
            const labels = Storage.loadLabels();
            const authorNotes = Storage.loadAuthorNotes();
            let tagGroups = {};

            Object.entries(labels).forEach(([ficId, tag]) => {
                if (!tagGroups[tag]) tagGroups[tag] = [];
                tagGroups[tag].push(ficId);
            });

            const tagOrder = PRESET_TAGS;
            const sortedTags = tagOrder.filter(tag => tagGroups[tag]);

            const tagsList = sortedTags.map(tag => {
                const count = tagGroups[tag].length;
                const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };

                return `
                    <div class="tag-item" data-tag="${tag}"
                         style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;
                                border-radius:6px;background:#44415a40;border:2px solid ${color.bg};
                                box-shadow:0 0 8px 2px ${color.bg}55;cursor:pointer;transition:all 0.2s;">
                        <span style="font-weight:bold;">${tag}</span>
                        <div style="display:flex;align-items:center;gap:10px;">
                            <span style="font-size:0.9em;">${count} work${count === 1 ? "" : "s"}</span>
                            ${(tag === 'Favourite' || tag === 'Dish') ? `
                                <button class="download-tag-btn" data-tag="${tag}"
        style="background:${color.bg};color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.8em;">📚 Download</button>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join("");

            const authorNotesSection = Object.keys(authorNotes).length > 0 ? `
                <div style="margin-top:20px;padding-top:20px;border-top:1px solid #555;">
                    <div class="author-notes-item" data-section="author-notes"
                         style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;
                                border-radius:6px;background:#44415a40;border:2px solid #e59888;
                                box-shadow:0 0 8px 2px #e5988855;cursor:pointer;transition:all 0.2s;">
                        <span style="font-weight:bold;">📝 Author Notes</span>
                        <span style="font-size:0.9em;">${Object.keys(authorNotes).length} author${Object.keys(authorNotes).length === 1 ? "" : "s"}</span>
                    </div>
                </div>
            ` : '';

            this.content.innerHTML = tagsList + authorNotesSection;
        }

        destroy() {
            this.content.removeEventListener("click", this.handleContentClick);
            this.content.removeEventListener("mouseenter", this.handleMouseEnter);
            this.content.removeEventListener("mouseleave", this.handleMouseLeave);
        }
    }

    class DownloadSelectionEventManager {
        constructor(modal) {
            this.modal = modal;
            this.setupEventDelegation();
        }

        setupEventDelegation() {
            this.modal.addEventListener("click", this.handleModalClick.bind(this));
            this.modal.addEventListener("change", this.handleCheckboxChange.bind(this));
        }

        handleModalClick(e) {
            const target = e.target;

            if (target.closest('#works-container')) {
                e.stopPropagation();
            }

            if (target.closest('.fic-item')) {
                const ficItem = target.closest('.fic-item');
                const checkbox = ficItem.querySelector('.work-checkbox');
                if (checkbox && target !== checkbox) {
                    checkbox.checked = !checkbox.checked;
                    ficItem.classList.toggle('selected', checkbox.checked);
                    this.updateSelectedCount();
                }
            }

            else if (target.matches('#select-all')) {
                this.selectAll();
            }
            else if (target.matches('#select-none')) {
                this.selectNone();
            }
            else if (target.matches('#select-new')) {
                this.selectNew();
            }

            else if (target.matches('#download-selected')) {
                this.downloadSelected();
            }
            else if (target.matches('#cancel-selection')) {
                this.cancelSelection();
            }
        }

        handleCheckboxChange(e) {
            if (e.target.matches('.work-checkbox')) {
                const ficItem = e.target.closest('.fic-item');
                if (ficItem) {
                    ficItem.classList.toggle('selected', e.target.checked);
                }
                this.updateSelectedCount();
            }
        }

        updateSelectedCount() {
            const checkboxes = this.modal.querySelectorAll('.work-checkbox');
            const selectedCount = this.modal.querySelector('#selected-count');
            const downloadBtn = this.modal.querySelector('#download-selected');

            if (selectedCount && downloadBtn) {
                const selected = Array.from(checkboxes).filter(cb => cb.checked);
                selectedCount.textContent = `${selected.length} selected`;
                downloadBtn.disabled = selected.length === 0;
            }
        }

        selectAll() {
            const checkboxes = this.modal.querySelectorAll('.work-checkbox');
            const ficItems = this.modal.querySelectorAll('.fic-item');
            checkboxes.forEach((cb, index) => {
                cb.checked = true;
                if (ficItems[index]) ficItems[index].classList.add('selected');
            });
            this.updateSelectedCount();
        }

        selectNone() {
            const checkboxes = this.modal.querySelectorAll('.work-checkbox');
            const ficItems = this.modal.querySelectorAll('.fic-item');
            checkboxes.forEach((cb, index) => {
                cb.checked = false;
                if (ficItems[index]) ficItems[index].classList.remove('selected');
            });
            this.updateSelectedCount();
        }

selectNew() {
    const downloadHistory = Storage.loadDownloadHistory();
    const checkboxes = this.modal.querySelectorAll('.work-checkbox');
    const ficItems = this.modal.querySelectorAll('.fic-item');

    checkboxes.forEach((cb, index) => {
        const ficId = cb.dataset.ficId;
        const isNew = !downloadHistory[ficId]; // Check individual fic download history
        cb.checked = isNew;
        if (ficItems[index]) {
            ficItems[index].classList.toggle('selected', isNew);

            const statusSpan = ficItems[index].querySelector('span[style*="color"]');
            if (statusSpan) {
                if (isNew) {
                    statusSpan.textContent = 'New';
                    statusSpan.style.color = '#51cf66';
                } else {
                    statusSpan.textContent = 'Previously downloaded';
                    statusSpan.style.color = '#ff6b6b';
                }
            }
        }
    });
    this.updateSelectedCount();
}

        downloadSelected() {
            const checkboxes = this.modal.querySelectorAll('.work-checkbox');
            const selected = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.dataset.ficId);

            if (this.onDownloadSelected) {
                this.onDownloadSelected(selected);
            }
        }

        cancelSelection() {
            if (this.onCancelSelection) {
                this.onCancelSelection();
            }
        }

        destroy() {
        }

      refreshDownloadStatus() {
    const downloadHistory = Storage.loadDownloadHistory();
    const ficItems = this.modal.querySelectorAll('.fic-item');

    ficItems.forEach(ficItem => {
        const checkbox = ficItem.querySelector('.work-checkbox');
        if (checkbox) {
            const ficId = checkbox.dataset.ficId;
            const isNew = !downloadHistory[ficId];

            const statusSpan = ficItem.querySelector('span[style*="color"]');
            if (statusSpan) {
                if (isNew) {
                    statusSpan.textContent = 'New';
                    statusSpan.style.color = '#51cf66';
                } else {
                    statusSpan.textContent = 'Previously downloaded';
                    statusSpan.style.color = '#ff6b6b';
                }
            }
        }
    });
}

    }

    class WorkItemEventManager {
        constructor() {
            this.setupEventDelegation();
        }

        setupEventDelegation() {
            // Attach to document body to catch all work items
            document.body.addEventListener("click", this.handleWorkClick.bind(this));
            document.body.addEventListener("mouseenter", this.handleWorkHover.bind(this), true);
            document.body.addEventListener("mouseleave", this.handleWorkLeave.bind(this), true);
        }

handleWorkClick(e) {
    const target = e.target;

    if (target.closest('.work-collapsed, .work-expanded') &&
    !target.closest('a, button, .ao3-tag-btn')) {
    const work = target.closest('li.work.blurb, .work.blurb, li.bookmark.blurb');  // Add bookmark support
    if (work) {
        e.preventDefault();
        e.stopPropagation();
        toggleWorkCollapse(work);
        return;
    }
}

    else if (target.matches('.ao3-tag-btn')) {
        e.stopPropagation();
        const workId = target.dataset.workId;
        const tag = target.textContent;
        this.handleTagButtonClick(workId, tag, target);
    }

            // Note save/cancel buttons
            else if (target.matches('.note-save-btn')) {
                const container = target.closest('.fic-note-wrapper');
                this.handleNoteSave(container);
            }
            else if (target.matches('.note-cancel-btn')) {
                const container = target.closest('.fic-note-wrapper');
                this.handleNoteCancel(container);
            }
            else if (target.matches('.note-edit-btn')) {
                const container = target.closest('.fic-note-wrapper');
                this.handleNoteEdit(container);
            }
            else if (target.matches('.note-delete-btn')) {
                const container = target.closest('.fic-note-wrapper');
                this.handleNoteDelete(container);
            }
            else if (target.matches('.note-add-btn')) {
                const container = target.closest('.fic-note-wrapper');
                this.handleNoteAdd(container);
            }
        }

        handleWorkHover(e) {
            const target = e.target;

            if (target.matches('.ao3-tag-btn')) {
                const currentTag = Storage.loadLabels()[target.dataset.workId];
                const tag = target.textContent;
                if (currentTag !== tag) {
                    target.style.background = '#f0f0f0';
                }
            }
        }

        handleWorkLeave(e) {
            const target = e.target;

            if (target.matches('.ao3-tag-btn')) {
                const currentTag = Storage.loadLabels()[target.dataset.workId];
                const tag = target.textContent;
                if (currentTag !== tag) {
                    target.style.background = '#fff';
                }
            }
        }

handleTagButtonClick(workId, tag, button) {
    const work = button.closest('li.work.blurb, .work.blurb, li.bookmark.blurb');

    console.log('Tag clicked, work element:', work);
    console.log('Work classes:', work.className);

    toggleWorkTag(workId, tag);

    if (work) {
        this.refreshWorkTagging(work, workId);
    }
}

        handleNoteSave(container) {
            if (container && container.saveNote) {
                container.saveNote();
            }
        }

        handleNoteCancel(container) {
            if (container && container.cancelEdit) {
                container.cancelEdit();
            }
        }

        handleNoteEdit(container) {
            const noteData = container.querySelector('.note-text');
            if (container && container.showEditor && noteData) {
                container.showEditor(noteData.textContent);
            }
        }

        handleNoteDelete(container) {
            if (container && container.deleteNote) {
                container.deleteNote();
            }
        }

        handleNoteAdd(container) {
            if (container && container.showEditor) {
                container.showEditor("");
            }
        }

        refreshWorkTagging(work, workId) {
            work.dataset.processed = 'false';
            const existingTags = work.querySelector('.ao3-tag-buttons');
            const existingNotes = work.querySelector('.ao3-note-container');
            const existingTitleTag = work.querySelector('.ao3-title-tag');

            if (existingTags) existingTags.remove();
            if (existingNotes) existingNotes.remove();
            if (existingTitleTag) existingTitleTag.remove();

            addCompleteTagging(work, workId);
            applyWorkStyling(work, workId);
        }
    }

    class MetadataCache {

static get(workId) {
    const cache = Storage.loadMetadataCache();
    const cached = cache[workId];

    if (cached) {
        if (cached.data && cached.data.title && cached.data.author) {
            return cached.data;  // New structure with wrapper
        } else if (cached.title && cached.author) {
            return cached;  // Old structure, direct data
        }
    }
    return null;
}

static set(workId, data) {
    try {
        const cache = Storage.loadMetadataCache();
        cache[workId] = {
            timestamp: Date.now(),
            data: data
        };
        Storage.saveMetadataCache(cache);
    } catch (error) {
        console.error(`Failed to cache metadata for work ${workId}:`, error);
    }
}

static async fetchWorkMetadata(workId, skipNetworkFetch = false) {
    const cached = this.get(workId);
    if (cached && cached.title && cached.author) {
        console.log(`Using cached metadata for work ${workId}: ${cached.title}`);
        return cached;
    }

    if (skipNetworkFetch) {
        console.log(`No cached data for work ${workId}, returning placeholder`);
        return this.createFallback(workId, 'needsRefresh');
    }

    console.log(`No cached metadata found for work ${workId}, fetching from AO3...`);

    try {
        const response = await this.fetchWorkPage(workId);
        const html = await response.text();

        const pageStatus = this.analyzePageStatus(html, response.status);
        if (pageStatus !== 'success') {
            return this.createFallback(workId, pageStatus);
        }

        const metadata = this.parseWorkMetadata(html, workId);
        console.log(`Successfully fetched metadata for ${workId}:`, metadata);

        if (this.isValidMetadata(metadata, workId)) {
            this.set(workId, metadata);
        }

        return metadata;

    } catch (error) {
        console.error(`Failed to fetch metadata for work ${workId}:`, error);
        return this.createFallback(workId, 'networkError');
    }
}
        static async fetchWorkPage(workId) {
            await new Promise(resolve =>
                setTimeout(resolve, Math.random() * 500 + 500)
            );

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 20000);

            try {
                const response = await fetch(
                    `https://archiveofourown.org/works/${workId}?view_adult=true&view_full_work=true`,
                    {
                        method: 'GET',
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                            'Accept-Language': 'en-US,en;q=0.5',
                            'Accept-Encoding': 'gzip, deflate, br',
                            'DNT': '1',
                            'Connection': 'keep-alive',
                            'Upgrade-Insecure-Requests': '1',
                            'Referer': 'https://archiveofourown.org/',
                        },
                        credentials: 'include',
                        signal: controller.signal
                    }
                );

                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }

        static analyzePageStatus(html, statusCode) {
            if (statusCode === 403) {
                return 'accessDenied';
            }

            if (!statusCode || statusCode >= 400) {
                return 'httpError';
            }

            if (html.includes('Log In') && html.includes('sign up') || html.includes('Access denied')) {
                return 'restrictedAccess';
            }

            if (html.includes('adult content warning') || html.includes('This work could have adult content')) {
                return 'adultWarning';
            }

            return 'success';
        }

        static parseWorkMetadata(html, workId) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            const title = this.extractTitle(doc, workId);
            const author = this.extractAuthor(doc);

            return { title, author };
        }

        static extractTitle(doc, workId) {
            const titleSelectors = [
                'h2.title',
                '.title h2',
                'h2.heading',
                '.work h2',
                'h1.title',
                '.preface h2.title',
                '#workskin .title h2',
                '.work .preface .title'
            ];

            for (const selector of titleSelectors) {
                const titleEl = doc.querySelector(selector);
                if (titleEl?.textContent?.trim()) {
                    const title = titleEl.textContent.trim();
                    console.log(`Found title with selector "${selector}": ${title}`);
                    return title;
                }
            }

            const pageTitle = doc.querySelector('title')?.textContent;
            if (pageTitle?.includes(' - ')) {
                const parts = pageTitle.split(' - ');
                if (parts.length >= 2) {
                    const title = parts[0].trim();
                    console.log(`Extracted title from page title: ${title}`);
                    return title;
                }
            }

            return `Work ${workId}`;
        }

        static extractAuthor(doc) {
            let author = null;

            const authorSelectors = [
                'a[rel="author"]',
                '.preface .byline a[href*="/users/"]',
                '.work .byline a[href*="/users/"]',
                '#workskin .byline a[href*="/users/"]'
            ];

            for (const selector of authorSelectors) {
                const authorEl = doc.querySelector(selector);
                if (authorEl && authorEl.textContent.trim()) {
                    const authorText = authorEl.textContent.trim();
                    if (!authorText.toLowerCase().startsWith('hi,') && !authorText.includes('Log In')) {
                        author = authorText;
                        console.log(`Found author with selector "${selector}": ${author}`);
                        break;
                    }
                }
            }

            if (!author) {
                const bylineText = doc.querySelector('.byline')?.textContent ||
                                  doc.querySelector('h3.byline')?.textContent ||
                                  doc.querySelector('.preface .byline')?.textContent;
                if (bylineText && bylineText.includes('Anonymous')) {
                    author = 'Anonymous';
                    console.log('Found anonymous author');
                }
            }

            return author || 'Unknown Author';
        }

        static createFallback(workId, reason) {
            const fallbacks = {
                needsRefresh: {
                    title: `Work ${workId}`,
                    author: 'Unknown Author',
                    needsRefresh: true
                },
                accessDenied: {
                    title: `[Access Denied] Work ${workId}`,
                    author: 'Unknown Author',
                    needsRefresh: true
                },
                restrictedAccess: {
                    title: `[Restricted Access] Work ${workId}`,
                    author: 'Unknown Author',
                    needsRefresh: true
                },
                adultWarning: {
                    title: `[Adult Content] Work ${workId}`,
                    author: 'Unknown Author',
                    needsRefresh: true
                },
                httpError: {
                    title: `Work ${workId}`,
                    author: 'Unknown Author',
                    needsRefresh: true
                },
                networkError: {
                    title: `Work ${workId}`,
                    author: 'Unknown Author',
                    needsRefresh: true
                }
            };

            return fallbacks[reason] || fallbacks.networkError;
        }

        static isValidMetadata(metadata, workId) {
            return metadata.title &&
                   metadata.title !== `Work ${workId}` &&
                   !metadata.title.includes('[Adult Content]') &&
                   !metadata.title.includes('[Access Denied]') &&
                   !metadata.title.includes('[Restricted Access]');
        }

        static clearBadCache() {
            const cache = Storage.loadMetadataCache();
            const cleaned = {};

            Object.entries(cache).forEach(([workId, entry]) => {
                if (!entry.title.startsWith('Work ') || entry.author !== 'Unknown Author') {
                    cleaned[workId] = entry;
                }
            });

            Storage.saveMetadataCache(cleaned);
            console.log('Cleared fallback cache entries');
        }

        static async refreshMetadataForTag(tag) {
            const labels = Storage.loadLabels();
            const works = Object.keys(labels).filter(id => labels[id] === tag);

            const worksNeedingRefresh = [];
            for (const workId of works) {
                const cached = this.get(workId);
                if (!cached ||
                    /^Work \d{6,8}$/.test(cached.title) ||
                    cached.author === 'Unknown Author' ||
                    cached.author.toLowerCase() === 'log in' ||
                    cached.title.toLowerCase().includes('adult content warning') ||
                    cached.title.includes('[Adult Content]') ||
                    cached.needsRefresh === true) {
                    worksNeedingRefresh.push(workId);
                }
            }

            console.log(`Refreshing ${worksNeedingRefresh.length} of ${works.length} works that need updates`);

            if (worksNeedingRefresh.length === 0) {
                alert('All titles are already up to date!');
                return;
            }

            for (const workId of worksNeedingRefresh) {
                try {
                    const actualWorkId = workId.replace("bookmark_", "").replace(/^.*?(\d+).*$/, "$1");
                    const metadata = await this.fetchWorkMetadata(actualWorkId, false);
                    console.log(`Refreshed: ${workId} -> ${metadata.title}`);
                } catch (error) {
                    console.error(`Failed to refresh ${workId}:`, error);
                }
            }

            console.log('Metadata refresh complete');
        }
    }

async function fetchWorkSummary(workId) {
    if (!workId || !/^\d+$/.test(workId)) {
        return Promise.resolve('');
    }

    return new Promise((resolve) => {
        GM_xmlhttpRequest({
            method: 'GET',
            url: `https://archiveofourown.org/works/${workId}`,
            timeout: 15000,
            onload: (response) => {
                let summary = '';
                if (response.status === 200) {
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(response.responseText, 'text/html');
                        const summaryEl = doc.querySelector('.summary blockquote') ||
                                         doc.querySelector('.summary .userstuff') ||
                                         doc.querySelector('#workskin .summary');

                        if (summaryEl && summaryEl.textContent.trim()) {
                            summary = summaryEl.textContent.trim();
                        }
                    } catch (error) {
                        console.error(`Error fetching summary for work ${workId}:`, error);
                    }
                }
                resolve(summary);
            },
            onerror: () => resolve(''),
            ontimeout: () => resolve('')
        });
    });
}

    class MassDownloadManager {
        constructor() {
            this.isDownloading = false;
            this.downloadQueue = [];
            this.downloadedCount = 0;
            this.totalCount = 0;
            this.progressModal = null;
            this.currentTag = null;
        }

        async downloadTaggedWorks(tag) {
            if (this.isDownloading) {
                alert('Download already in progress!');
                return;
            }

            const labels = Storage.loadLabels();
            const taggedIds = Object.keys(labels).filter(id => labels[id] === tag);

            if (taggedIds.length === 0) {
                alert(`No fics tagged as "${tag}" found!`);
                return;
            }

            const lastDownload = this.getLastDownloadTime(tag);
            const selectedIds = await this.showSelectionModal(tag, taggedIds, lastDownload);

            if (!selectedIds || selectedIds.length === 0) return;

            this.startDownload(selectedIds, tag);
        }

        async showSelectionModal(tag, allIds, lastDownloadTime) {
            return new Promise(async (resolve) => {
                const loadingModal = UI.createModal(`
                    <h3>Loading works for download selection...</h3>
                    <div style="text-align:center;margin:20px 0;">
                        <div style="display:inline-block;width:40px;height:40px;border:4px solid #f3f3f3;border-top:4px solid #3498db;border-radius:50%;animation:spin 1s linear infinite;"></div>
                    </div>
                `);

const workData = await Promise.all(
    allIds.map(async (ficId) => {
        const workId = normalizeWorkId(ficId);
        const metadata = await MetadataCache.fetchWorkMetadata(workId);
        return { ficId, workId, metadata };
    })
);

const downloadHistory = Storage.loadDownloadHistory();
const tagHistory = downloadHistory[tag] || 0;

loadingModal.remove();

const worksList = workData.map(({ ficId, workId, metadata }) => {
    const isNew = !downloadHistory[ficId];

    return `
<div class="fic-item" style="display:flex;align-items:center;gap:10px;padding:8px;border-left:4px solid #666;border-radius:4px;margin:4px 0;background:#44415a40;cursor:pointer;">
    <input type="checkbox" class="work-checkbox" data-fic-id="${ficId}" ${isNew ? 'checked' : ''}>
    <div style="flex:1;">
        <div style="font-weight:bold;color:#fff;">${metadata.title}</div>
        <div style="font-size:0.9em;color:#ccc;">by ${metadata.author}</div>
        <div style="font-size:0.8em;color:#999;">ID: ${workId}</div>
    </div>
    ${!isNew ? '<span style="color:#ff6b6b;font-size:0.8em;">Previously downloaded</span>' : '<span style="color:#51cf66;font-size:0.8em;">New</span>'}
</div>
    `;
}).join("");

                const modal = UI.createModal(`
                    <div style="max-width:700px;max-height:600px;">
                        <div style="margin-bottom:15px;">
                            ${lastDownloadTime ? `Last downloaded: ${new Date(lastDownloadTime).toLocaleDateString()}` : 'First time downloading this tag'}
                        </div>

<div style="margin-bottom:15px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
    <button id="select-all" style="background:#4CAF50;color:white;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;">Select All</button>
    <button id="select-none" style="background:#ff9800;color:white;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;">Select None</button>
    <button id="select-new" style="background:#2196F3;color:white;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;">Select New</button>
    <span id="selected-count" style="margin-left:10px;font-weight:bold;">0 selected</span>
</div>

                        <div id="works-container" style="max-height:300px;overflow-y:auto;border:1px solid #ddd;border-radius:4px;padding:10px;background:#232136CC;">
                            ${worksList}
                        </div>

                        <div style="display:flex;gap:10px;margin-top:20px;">
                            <button id="download-selected" style="background:#4CAF50;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;flex:1;" disabled>Download Selected</button>
                            <button id="cancel-selection" style="background:#f44336;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;flex:1;">Back</button>
                        </div>
                    </div>
                `, `Select ${tag} Works to Download`);

                // Use event delegation for this modal
                const eventManager = new DownloadSelectionEventManager(modal);
                eventManager.currentTag = tag;
                modal._downloadEventManager = eventManager;

              setTimeout(() => {
    const checkboxes = modal.querySelectorAll('.work-checkbox');
    const ficItems = modal.querySelectorAll('.fic-item');

    checkboxes.forEach((checkbox, index) => {
        const ficId = checkbox.dataset.ficId;
        const isNew = !downloadHistory[ficId];

        if (isNew) {
            checkbox.checked = true;

            if (ficItems[index]) {
                ficItems[index].classList.add('selected');
            }
        }
    });


    if (eventManager.updateSelectedCount) {
        eventManager.updateSelectedCount();
    }
}, 0);

              eventManager.onDownloadSelected = (selected) => {
                    eventManager.destroy();
                    modal.remove();
                    resolve(selected);
                };
                eventManager.onCancelSelection = () => {
                    eventManager.destroy();
                    modal.remove();
                    resolve(null);
                };

                eventManager.updateSelectedCount();
            });
        }

        startDownload(selectedIds, tag) {
            this.isDownloading = true;
            this.downloadQueue = selectedIds.slice();
            this.downloadedCount = 0;
            this.totalCount = selectedIds.length;
            this.currentTag = tag;

            this.showProgressModal();
            this.processDownloadQueue();
        }

        showProgressModal() {
            this.progressModal = UI.createModal(`
                <h3 style="text-align:center;color:#c4a7e7;">📚 Downloading Tagged Works</h3>
                <div style="margin:15px 0;">
                    <div style="background:#44415a;border-radius:10px;overflow:hidden;height:20px;position:relative;">
                        <div id="download-progress" style="background:linear-gradient(90deg, #c4a7e7, #e8c8dc);height:100%;width:0%;transition:width 0.3s;"></div>
                        <div style="position:absolute;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;color:#000;">
                            <span id="progress-text">0 / ${this.totalCount}</span>
                        </div>
                    </div>
                </div>
                <div id="current-download" style="text-align:center;margin:10px 0;font-size:14px;color:#ccc;">Preparing download...</div>
                <div style="text-align:center;margin-top:20px;">
                    <button id="cancel-download" style="background:#f44336;color:white;border:none;padding:8px 16px;border-radius:4px;cursor:pointer;">Cancel</button>
                </div>
            `);

            document.getElementById('cancel-download').addEventListener('click', () => {
                this.isDownloading = false;
                this.progressModal.remove();
                this.progressModal = null;
            });
        }

        async processDownloadQueue() {
            while (this.downloadQueue.length > 0 && this.isDownloading) {
                const ficId = this.downloadQueue.shift();

                document.getElementById('current-download').textContent = `Downloading: ${ficId}`;

                try {
                    await this.downloadFic(ficId);
                } catch (error) {
                    console.error(`Failed to download ${ficId}:`, error);
                }

                this.downloadedCount++;
                const percentage = (this.downloadedCount / this.totalCount) * 100;
                document.getElementById('download-progress').style.width = `${percentage}%`;
                document.getElementById('progress-text').textContent = `${this.downloadedCount} / ${this.totalCount}`;

                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            if (this.isDownloading) {
                this.finalizeDownloads();
            }
        }

        async downloadFic(ficId) {
            const workId = normalizeWorkId(ficId);

            const metadata = await MetadataCache.fetchWorkMetadata(workId);
            const htmlContent = await this.fetchWorkContent(workId);

            const cleanTitle = metadata.title.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_').substring(0, 100);
            const cleanAuthor = metadata.author.replace(/[<>:"/\\|?*\x00-\x1f]/g, '_').substring(0, 50);
            const filename = `${cleanAuthor} - ${cleanTitle} (${workId}).html`;

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            URL.revokeObjectURL(url);

const downloadHistory = Storage.loadDownloadHistory();
downloadHistory[ficId] = Date.now();
Storage.saveDownloadHistory(downloadHistory);
        }

        fetchWorkContent(workId) {
            const downloadUrl = `https://download.archiveofourown.org/downloads/${workId}/work_${workId}.html`;

            return new Promise((resolve, reject) => {
                GM_xmlhttpRequest({
                    method: 'GET',
                    url: downloadUrl,
                    timeout: 30000,
                    onload: (response) => {
                        if (response.status === 200) {
                            resolve(response.responseText);
                        } else {
                            reject(new Error(`HTTP ${response.status}`));
                        }
                    },
                    onerror: () => reject(new Error('Network error')),
                    ontimeout: () => reject(new Error('Request timeout'))
                });
            });
        }

finalizeDownloads() {
    this.progressModal?.remove();
    this.progressModal = null;
    this.isDownloading = false;

    const selectionModal = document.querySelector('#works-container');
    if (selectionModal) {
        const modal = selectionModal.closest('[class*="backdrop"]');
        if (modal && modal._downloadEventManager) {
            modal._downloadEventManager.refreshDownloadStatus();
        }
    }

    alert(`Downloads complete! ${this.downloadedCount} files downloaded.`);
}

        getLastDownloadTime(tag) {
            const history = Storage.loadDownloadHistory();
            return history[tag] || 0;
        }

        setLastDownloadTime(tag, timestamp) {
            const history = Storage.loadDownloadHistory();
            history[tag] = timestamp;
            Storage.saveDownloadHistory(history);
        }
    }

    function createNoteUI(id, isAuthor = false) {
        const notes = isAuthor ? Storage.loadAuthorNotes() : Storage.loadNotes();
        const data = notes[id];

        const wrapper = document.createElement("div");
        wrapper.className = "fic-note-wrapper";
        wrapper.style.cssText = "margin:8px 0;text-align:center;max-width:600px;margin-left:auto;margin-right:auto;";

        function showAddButton() {
            wrapper.innerHTML = "";

            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "note-add-btn";
            btn.textContent = isAuthor ? "📝 Add Author Note" : "📝 Add Story Note";
            btn.style.cssText = "border:1.5px dashed #999; background:transparent; cursor:pointer; padding:4px; font-size:0.9em; border-radius:4px; display:inline-block; text-align:center;";

            wrapper.appendChild(btn);
        }

        function showNote(noteData) {
            wrapper.innerHTML = "";

            const outer = document.createElement("div");
            outer.style.cssText = "padding:6px;border:1.5px solid #999;border-radius:4px;background:transparent;";

            const header = document.createElement("div");
            header.style.cssText = "display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;";

            const title = document.createElement("strong");
            title.textContent = isAuthor ? "📝 Your Author Note" : "📝 Your Story Note";
            title.style.cssText = "font-size:0.9em;position: relative; top: 4px;";

            const controls = document.createElement("div");
            controls.style.cssText = "display:flex;gap:6px;align-items:center;";

            const ts = document.createElement("span");
            ts.textContent = noteData.date;
            ts.style.cssText = "color:#777;font-size:0.7em;position: relative; top: 4px;";

            const ebtn = document.createElement("button");
            ebtn.textContent = "✏️";
            ebtn.className = "note-edit-btn";
            ebtn.style.cssText = "background: transparent; border: none; cursor: pointer; font-size:0.8em;";

            const dbtn = document.createElement("button");
            dbtn.textContent = "🗑️";
            dbtn.className = "note-delete-btn";
            dbtn.style.cssText = "background: transparent; border: none; cursor: pointer; font-size:0.8em;";

            controls.append(ts, ebtn, dbtn);
            header.append(title, controls);

            const content = document.createElement("div");
            content.className = "note-text";
            content.textContent = noteData.text;
            content.style.cssText = "white-space:pre-wrap;width:100%;box-sizing:border-box;border-top:1px solid #ccc;padding-top:8px;margin-top:8px;font-size:0.85em;text-align:center;";

            outer.append(header, content);
            wrapper.appendChild(outer);
        }

        function showEditor(text) {
            wrapper.innerHTML = "";

            const container = document.createElement("div");
            container.style.cssText = "text-align:center;";

            const ta = document.createElement("textarea");
            ta.value = text || "";
            ta.style.cssText = "width:100%;min-height:80px;border:1px solid #ccc;border-radius:6px;padding:6px;resize:vertical;overflow:hidden;font-family:inherit;";

            function autoResize() {
                ta.style.height = 'auto';
                ta.style.height = ta.scrollHeight + 'px';
            }

// Use older event handling for better compatibility
if (ta.addEventListener) {
    ta.addEventListener('input', autoResize);
    ta.addEventListener('keyup', autoResize);
    ta.addEventListener('paste', function() {
        setTimeout(autoResize, 0);
    });
} else if (ta.attachEvent) {
    // IE8 and older
    ta.attachEvent('onpropertychange', autoResize);
    ta.attachEvent('onkeyup', autoResize);
    ta.attachEvent('onpaste', function() {
        setTimeout(autoResize, 0);
    });
}

// Initial resize with delay for older browsers
autoResize();

            container.appendChild(ta);

            const row = document.createElement("div");
            row.style.cssText = "margin-top:8px;";

            const saveBtn = document.createElement("button");
            saveBtn.textContent = "💾 Save";
            saveBtn.className = "note-save-btn";
            saveBtn.style.cssText = "background: transparent; border: none; cursor: pointer; margin-right:6px;";

            const cancelBtn = document.createElement("button");
            cancelBtn.textContent = "❌ Cancel";
            cancelBtn.className = "note-cancel-btn";
            cancelBtn.style.cssText = "background: transparent; border: none; cursor: pointer;";

            row.append(saveBtn, cancelBtn);
            container.appendChild(row);
            wrapper.appendChild(container);
        }

        wrapper.showEditor = showEditor;
wrapper.saveNote = function() {
    const textarea = this.querySelector("textarea");
    const text = textarea.value.trim();

    if (!text) {
        showAddButton();
        return;
    }

    const notes = isAuthor ? Storage.loadAuthorNotes() : Storage.loadNotes();

    const timestamp = notes[id] && notes[id].date ? notes[id].date : UI.formatDateTime(new Date());
    notes[id] = { text, date: timestamp };

    if (isAuthor) Storage.saveAuthorNotes(notes);
    else Storage.saveNotes(notes);

    showNote(notes[id]);
};

        wrapper.cancelEdit = function() {
            const notes = isAuthor ? Storage.loadAuthorNotes() : Storage.loadNotes();
            if (notes[id]) showNote(notes[id]);
            else showAddButton();
        };

wrapper.deleteNote = function() {
    if (!confirm(isAuthor ? "Delete this author note?" : "Delete this note?")) return;

    const notes = isAuthor ? Storage.loadAuthorNotes() : Storage.loadNotes();
    delete notes[id];

    if (isAuthor) {
        Storage.saveAuthorNotes(notes);
        // Track deletion for sync
        const deletedAuthorNotes = Storage.loadDeletedAuthorNotes();
        deletedAuthorNotes[id] = Date.now();
        Storage.saveDeletedAuthorNotes(deletedAuthorNotes);
    } else {
        Storage.saveNotes(notes);
        // Track deletion for sync
        const deletedNotes = Storage.loadDeletedNotes();
        deletedNotes[id] = Date.now();
        Storage.saveDeletedNotes(deletedNotes);
    }

    showAddButton();
};

        if (data) showNote(data);
        else showAddButton();

        return wrapper;
    }

    function addSettingsButton() {
        const nav = document.querySelector("ul.primary.navigation.actions") ||
                   document.querySelector("ul.primary.navigation") ||
                   document.querySelector("nav ul");

        if (!nav || document.querySelector("#browse-fics-btn")) return;

        const tagsLi = document.createElement("li");
        tagsLi.innerHTML = '<a href="#" id="browse-fics-btn">Fics</a>';
        nav.appendChild(tagsLi);

        tagsLi.querySelector("a").addEventListener("click", (e) => {
            e.preventDefault();
            createTagBrowserModal();
        });
    }

    function createTagBrowserModal() {
        if (document.getElementById("tag-browser-modal")) return;

        const labels = Storage.loadLabels();
        const authorNotes = Storage.loadAuthorNotes();

        let tagGroups = {};
        Object.entries(labels).forEach(([ficId, tag]) => {
            if (!tagGroups[tag]) tagGroups[tag] = [];
            tagGroups[tag].push(ficId);
        });

        const tagOrder = PRESET_TAGS;
        const sortedTags = tagOrder.filter(tag => tagGroups[tag]);

        if (sortedTags.length === 0 && Object.keys(authorNotes).length === 0) {
            UI.createModal(`
                <div style="text-align:center;color:#d32f2f;">No tagged fics or author notes found.</div>
            `);
            return;
        }

        const tagsList = sortedTags.map(tag => {
            const count = tagGroups[tag].length;
            const color = TAG_COLORS[tag] || { bg: "#6e6a86", text: "#000" };

            return `
                <div class="tag-item" data-tag="${tag}"
                     style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;
                            border-radius:6px;background:#44415a40;border:2px solid ${color.bg};
                            box-shadow:0 0 8px 2px ${color.bg}55;cursor:pointer;transition:all 0.2s;">
                    <span style="font-weight:bold;">${tag}</span>
                    <div style="display:flex;align-items:center;gap:10px;">
                        <span style="font-size:0.9em;">${count} work${count === 1 ? "" : "s"}</span>
                        ${(tag === 'Favourite' || tag === 'Dish') ? `
<button class="download-tag-btn" data-tag="${tag}"
        style="background:${color.bg};color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:0.8em;">📚 Download</button>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join("");

        const authorNotesSection = Object.keys(authorNotes).length > 0 ? `
            <div style="margin-top:20px;padding-top:20px;border-top:1px solid #555;">
                <div class="author-notes-item" data-section="author-notes"
                     style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;margin:4px 0;
                            border-radius:6px;background:#44415a40;border:2px solid #e59888;
                            box-shadow:0 0 8px 2px #e5988855;cursor:pointer;transition:all 0.2s;">
                    <span style="font-weight:bold;">📝 Author Notes</span>
                    <span style="font-size:0.9em;">${Object.keys(authorNotes).length} author${Object.keys(authorNotes).length === 1 ? "" : "s"}</span>
                </div>
            </div>
        ` : '';

        const modal = document.createElement("div");
        modal.id = "tag-browser-modal";
        modal.innerHTML = `
            <div class="backdrop" style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:100000;display:flex;align-items:center;justify-content:center;">
                <div style="background:#232136CC;color:#fff;padding:0;border-radius:8px;width:90%;max-width:600px;height:80%;max-height:700px;display:flex;flex-direction:column;border:1px solid #ddd;">
                    <div style="padding:20px;border-bottom:1px solid #ddd;display:flex;justify-content:space-between;align-items:center;">
                        <h3 style="margin:0;color:#fff;">Browse Tagged Fics (${Object.keys(labels).length} total)</h3>
                    </div>
                    <div id="tag-browser-content" style="flex:1;overflow-y:auto;padding:20px;">
                        ${tagsList}
                        ${authorNotesSection}
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        const eventManager = new TagBrowserEventManager(modal);

        modal.addEventListener("click", e => {
            if (e.target.classList.contains('backdrop')) {
                eventManager.destroy();
                modal.remove();
            }
        });

        modal._eventManager = eventManager;
    }

    function processWorksOnPage() {
            const workBlurbs = document.querySelectorAll('li.work.blurb, .work.blurb, li.bookmark.blurb');
        workBlurbs.forEach(work => {
            if (work.dataset.processed) return;
            work.dataset.processed = 'true';

            const workId = extractWorkId(work);
            if (workId) {
                addCompleteTagging(work, workId);
                applyWorkStyling(work, workId);
            }
        });
    }

function processStoryPage() {
    const workMatch = window.location.pathname.match(/\/works\/(\d+)/);
    if (!workMatch) return;

    const workId = workMatch[1];
    console.log('Processing story page for work:', workId);

    if (document.querySelector('.ao3-story-tagging')) return;

    const workMeta = document.querySelector('#workskin .preface') ||
                    document.querySelector('.work.meta.group') ||
                    document.querySelector('#main .wrapper');

    if (!workMeta) {
        console.log('Could not find insertion point for story page tagging');
        return;
    }

    const labels = Storage.loadLabels();
    const currentTag = labels[workId];

    const tagContainer = document.createElement('div');
    tagContainer.className = 'ao3-story-tagging';
    tagContainer.style.cssText = `margin: 20px 0;`;

    if (currentTag) {
        const tagDisplay = document.createElement('div');
        tagDisplay.id = 'current-tag-display'; // Add ID for easy updates
        tagDisplay.style.cssText = `
            text-align: center; margin-bottom: 10px; font-weight: bold;
            color: ${TAG_COLORS[currentTag].bg};
        `;
        tagDisplay.textContent = `Currently tagged: ${currentTag}`;
        tagContainer.appendChild(tagDisplay);
    }

    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
        display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 15px; justify-content: center;
    `;

    PRESET_TAGS.forEach(tag => {
        const btn = document.createElement('button');
        btn.textContent = tag;
        btn.className = 'ao3-tag-btn';
        btn.dataset.workId = workId;
        btn.style.cssText = `
            padding: 1px 6px; margin: 2px; border: 1px solid #ccc; border-radius: 4px;
            background: #eee; color: #333; font-size: 0.9em; cursor: pointer; transition: all 0.2s;
        `;

        if (currentTag === tag) {
            btn.style.background = TAG_COLORS[tag].bg;
            btn.style.color = TAG_COLORS[tag].text;
            btn.style.border = `1px solid ${TAG_COLORS[tag].bg}`;
        }

btn.addEventListener('mouseenter', () => {
    const labels = Storage.loadLabels();
    const activeTag = labels[workId];
    if (activeTag !== tag) {
        btn.style.background = '#f0f0f0';
    }
});

btn.addEventListener('mouseleave', () => {
    const labels = Storage.loadLabels();
    const activeTag = labels[workId];
    if (activeTag !== tag) {
        btn.style.background = '#eee';
    }
});
btn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();

    const currentLabels = Storage.loadLabels();
    const wasTagged = currentLabels[workId] === tag;

    if (wasTagged) {
        btn.style.background = '#eee';
        btn.style.color = '#333';
        btn.style.border = '1px solid #ccc';
        btn.style.fontWeight = 'normal';
    } else {
        btn.style.background = TAG_COLORS[tag].bg;
        btn.style.color = TAG_COLORS[tag].text;
        btn.style.border = `1px solid ${TAG_COLORS[tag].bg}`;
    }

    toggleWorkTag(workId, tag);

    const newLabels = Storage.loadLabels();
    const newCurrentTag = newLabels[workId];

    console.log(`Tag toggle: ${tag}, was tagged: ${wasTagged}, new tag: ${newCurrentTag}`);

    updateStoryPageTagging(workId, newCurrentTag);
});

        buttonContainer.appendChild(btn);
    });

    tagContainer.appendChild(buttonContainer);

    const noteUI = createNoteUI(workId, false);
    tagContainer.appendChild(noteUI);

    workMeta.parentNode.insertBefore(tagContainer, workMeta);
}

function updateStoryPageTagging(workId, currentTag) {
    const tagDisplay = document.getElementById('current-tag-display');
    const buttons = document.querySelectorAll('.ao3-tag-btn[data-work-id="' + workId + '"]');

    if (currentTag) {
        if (tagDisplay) {
            tagDisplay.textContent = `Currently tagged: ${currentTag}`;
            tagDisplay.style.color = TAG_COLORS[currentTag].bg;
        } else {
            const container = document.querySelector('.ao3-story-tagging');
            const buttonContainer = container.querySelector('div[style*="display: flex"]');

            const newDisplay = document.createElement('div');
            newDisplay.id = 'current-tag-display';
            newDisplay.style.cssText = `
                text-align: center; margin-bottom: 10px; font-weight: bold;
                color: ${TAG_COLORS[currentTag].bg};
            `;
            newDisplay.textContent = `Currently tagged: ${currentTag}`;
            container.insertBefore(newDisplay, buttonContainer);
        }
    } else {
        if (tagDisplay) {
            tagDisplay.remove();
        }
    }

    buttons.forEach(btn => {
        const btnTag = btn.textContent;
        if (currentTag === btnTag) {
            // This button is now active
            btn.style.background = TAG_COLORS[btnTag].bg;
            btn.style.color = TAG_COLORS[btnTag].text;
            btn.style.border = `1px solid ${TAG_COLORS[btnTag].bg}`;
        } else {
            // Reset inactive buttons
            btn.style.background = '#eee';
            btn.style.color = '#333';
            btn.style.border = '1px solid #ccc';
            btn.style.fontWeight = 'normal';
        }
    });
}

    function processAuthorPage() {
        const authorMatch = window.location.pathname.match(/\/users\/([^\/]+)(?:\/pseuds\/[^\/]+)?\/?$/);
        if (!authorMatch) return;

        const authorId = authorMatch[1];
        console.log('Processing author page for:', authorId);

        if (document.querySelector('.ao3-author-note')) return;

        const insertionPoints = [
            '#main .profile .module',
            '#main .profile',
            '#main .user.profile',
            '#main .wrapper',
            '.profile.module',
            '#main'
        ];

        let insertionPoint = null;
        for (const selector of insertionPoints) {
            insertionPoint = document.querySelector(selector);
            if (insertionPoint) {
                console.log('Found insertion point:', selector);
                break;
            }
        }

        if (!insertionPoint) {
            console.log('No suitable insertion point found for author notes');
            return;
        }

        const noteContainer = document.createElement('div');
        noteContainer.className = 'ao3-author-note';
        noteContainer.style.cssText = 'padding: 15px;';

        const noteUI = createNoteUI(authorId, true);
        noteContainer.appendChild(noteUI);

        if (insertionPoint.firstChild) {
            insertionPoint.insertBefore(noteContainer, insertionPoint.firstChild);
        } else {
            insertionPoint.appendChild(noteContainer);
        }

        console.log('Author note UI successfully added');
    }

function processSubscriptionPage() {
    const authorLinks = document.querySelectorAll('dt a[href*="/users/"]');

    authorLinks.forEach(link => {
        if (link.dataset.processed) return;
        link.dataset.processed = 'true';

        const authorMatch = link.href.match(/\/users\/([^\/]+)/);
        if (authorMatch) {
            const authorId = authorMatch[1];
            addAuthorNoteToSubscription(link, authorId);
        }
    });
}

function addAuthorNoteToSubscription(authorLink, authorId) {
    const authorNotes = Storage.loadAuthorNotes();
    const note = authorNotes[authorId];

    if (note) {
        const noteSpan = document.createElement('span');
        noteSpan.style.cssText = 'margin-left: 8px; font-size: 0.9em; font-style: italic;';
        noteSpan.textContent = `(Author Note: ${note.text})`;

        authorLink.parentNode.insertBefore(noteSpan, authorLink.nextSibling);
    }
}

  function extractWorkId(workElement) {
    // First try the existing method for regular work pages
    const link = workElement.querySelector('h4.heading a[href*="/works/"]');
    if (link) {
        const match = link.href.match(/\/works\/(\d+)/);
        if (match) return match[1];
    }

    if (workElement.classList.contains('bookmark')) {
        const classMatch = workElement.className.match(/work-(\d+)/);
        if (classMatch) return classMatch[1];
    }

    return null;
}
    function addCompleteTagging(work, workId) {
        const labels = Storage.loadLabels();
        const currentTag = labels[workId];

        const existingTags = work.querySelector('.ao3-tag-buttons');
        const existingNotes = work.querySelector('.ao3-note-container');
        const existingTitleTag = work.querySelector('.ao3-title-tag');
        if (existingTags) existingTags.remove();
        if (existingNotes) existingNotes.remove();
        if (existingTitleTag) existingTitleTag.remove();

        if (currentTag) {
            const titleTag = document.createElement('span');
            titleTag.className = 'ao3-title-tag';
            titleTag.textContent = `[${currentTag}] `;
            titleTag.style.color = TAG_COLORS[currentTag].bg;
            titleTag.style.fontWeight = "bold";
            titleTag.style.marginRight = "0.35em";

            const heading = work.querySelector('h4.heading a');
            if (heading) {
                heading.parentNode.insertBefore(titleTag, heading);
            }
        }

        const tagContainer = document.createElement('div');
        tagContainer.className = 'ao3-tag-buttons';

        const buttonRow = document.createElement('div');
        buttonRow.style.cssText = "display:flex;flex-wrap:wrap;justify-content:flex-end;gap:1px;margin-top:1em;margin-right:10px;width:100%;clear:both;";

        PRESET_TAGS.forEach(tag => {
            const btn = document.createElement('button');
            btn.textContent = tag;
            btn.className = 'ao3-tag-btn';
            btn.dataset.workId = workId;
            btn.style.cssText = `
    padding: 1px 6px; margin: 2px; border: 1px solid #ccc; border-radius: 4px;
    background: #eee; color: #333; font-size: 0.9em; cursor: pointer; transition: all 0.2s;
`;

            if (currentTag === tag) {
                btn.style.background = TAG_COLORS[tag].bg;
                btn.style.color = TAG_COLORS[tag].text;
                btn.style.border = `1px solid ${TAG_COLORS[tag].bg}`;
            }

            buttonRow.appendChild(btn);
        });

        tagContainer.appendChild(buttonRow);

        const stats = work.querySelector('dl.stats');
        if (stats) {
            stats.parentNode.insertBefore(tagContainer, stats.nextSibling);
        }

        const noteContainer = document.createElement('div');
        noteContainer.className = 'ao3-note-container';
        const noteUI = createNoteUI(workId, false);
        noteContainer.appendChild(noteUI);

        const fandoms = work.querySelector('.fandoms');
        if (fandoms) {
            fandoms.parentNode.insertBefore(noteContainer, fandoms.nextSibling);
        } else {
            const heading = work.querySelector('h4.heading');
            if (heading) {
                heading.parentNode.insertBefore(noteContainer, heading.nextSibling);
            }
        }
    }

function toggleWorkTag(workId, tag) {
    console.log(`toggleWorkTag called: workId=${workId}, tag=${tag}`);

    const labels = Storage.loadLabels();
    const currentTag = labels[workId];

    console.log(`Current tag before toggle: ${currentTag}`);

    if (currentTag === tag) {
        delete labels[workId];
        console.log(`Removed tag ${tag} from work ${workId}`);
    } else {
        labels[workId] = tag;
        console.log(`Set tag ${tag} for work ${workId}`);
    }

    Storage.saveLabels(labels);

    const savedLabels = Storage.loadLabels();
    const newTag = savedLabels[workId];
    console.log(`Tag after save: ${newTag}`);

    return newTag; // Return the new tag state for use by caller
}

function applyWorkStyling(work, workId) {
    const labels = Storage.loadLabels();
    const currentTag = labels[workId];

    work.style.border = '';
    work.style.boxShadow = '';
    work.style.borderRadius = '';
    work.style.opacity = '1.0';
    work.classList.remove('work-collapsed', 'work-expanded');

    const elementsToShow = work.querySelectorAll(".tags,.summary,.stats,.fandoms,blockquote,.series,.collections");
    elementsToShow.forEach(el => {
        el.style.display = "";
        el.classList.remove('collapsible-content');
    });

    const toggleElements = work.querySelectorAll('.work-toggle');
    toggleElements.forEach(el => {
        el.classList.remove('work-toggle');
        el.style.cursor = '';
    });

    work.classList.remove('work-toggle');
    work.style.cursor = '';

    if (!currentTag) {
        return;
    }

    if (BORDER_TAGS.includes(currentTag)) {
        const color = TAG_COLORS[currentTag]?.bg || "#000";
        work.style.border = `2px solid ${color}`;
        work.style.boxShadow = `0 0 8px 2px ${color}55`;
        work.style.borderRadius = "6px";
    }

const shouldCollapse = COLLAPSE_TAGS.includes(currentTag);
if (shouldCollapse) {
    let elementsToHide;
    if (work.classList.contains('bookmark')) {
        elementsToHide = work.querySelectorAll(".tags,.summary,.stats,.fandoms,blockquote:not(.own .notes),.series,.collections");
    } else {
        elementsToHide = work.querySelectorAll(".tags,.summary,.stats,.fandoms,blockquote,.series,.collections");
    }
        elementsToHide.forEach(el => {
            el.classList.add('collapsible-content');
        });

        work.classList.add('work-toggle');
        work.style.cursor = 'pointer';

        work.classList.add('work-collapsed');
        work.style.opacity = "0.6";

        if (!work.dataset.originalDisplayStored) {
            elementsToHide.forEach(el => {
                el.dataset.originalDisplay = el.style.display || getComputedStyle(el).display;
            });
            work.dataset.originalDisplayStored = 'true';
        }

        elementsToHide.forEach(el => {
            el.style.display = "none";
        });
    }
}

function toggleWorkCollapse(work) {
    const isCollapsed = work.classList.contains('work-collapsed');

    if (isCollapsed) {
        work.classList.remove('work-collapsed');
        work.classList.add('work-expanded');
        work.style.opacity = "1.0";

        const collapsibleElements = work.querySelectorAll('.collapsible-content');
        collapsibleElements.forEach(el => {
            el.style.display = el.dataset.originalDisplay || "";
        });
    } else {
        work.classList.remove('work-expanded');
        work.classList.add('work-collapsed');
        work.style.opacity = "0.6";

        const collapsibleElements = work.querySelectorAll('.collapsible-content');
        collapsibleElements.forEach(el => {
            el.style.display = "none";
        });
    }
}

    const downloadManager = new MassDownloadManager();
    let workItemManager = null;


    function main() {
        injectGlobalStyles();

        addSettingsButton();

        workItemManager = new WorkItemEventManager();

        processWorksOnPage();

        if (window.location.pathname.match(/\/works\/\d+/)) {
            processStoryPage();
        }

        if (window.location.pathname.match(/\/users\/[^\/]+(?:\/pseuds\/[^\/]+)?\/?$/)) {
            processAuthorPage();
        }
        if (window.location.pathname.match(/\/users\/[^\/]+\/subscriptions/)) {
            processSubscriptionPage();
        }
    }

    async function initializeAndRun() {
        try {
            await Storage.init();
            main();
        } catch (error) {
            console.error("Failed to initialize AO3 Tagging and Notes script:", error);
            alert("Could not initialize the AO3 Tagging and Notes script due to a database error. Please check the console for details.");
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeAndRun);
    } else {
        initializeAndRun();
    }

})();

