// ==UserScript==
// @name         AO3 Personal Tags
// @version      1.3.1
// @description  Add personal tags to AO3 works with customizable links (Firefox 115 ESR Compatible)
// @match        https://archiveofourown.org/*
// @icon         https://archiveofourown.org/favicon.ico
// @updateURL    https://raw.githubusercontent.com/micc4553/IndexedDB-Scripts/refs/heads/main/Personal%20Tags
// @downloadURL  https://raw.githubusercontent.com/micc4553/IndexedDB-Scripts/refs/heads/main/Personal%20Tags
// ==/UserScript==

(function() {
    'use strict';

    // Shared storage keys
    var KEYS = {
        PERSONAL_TAGS: "ao3_personal_tags",
        TAG_LOOKUP: "ao3_tag_lookup",
        TAG_LINKS: "ao3_tag_links",
        DELETED_PERSONAL_TAGS: "ao3_deleted_personal_tags", // Add this
        DELETED_TAG_LOOKUP: "ao3_deleted_tag_lookup"        // Add this
    };

// IndexedDB Storage Class - unified with Tagging and Notes
class Storage {
    static dbName = 'AO3DB';
    static dbVersion = 1;
    static storeName = 'data';
    static db = null;

    static async initDB() {
        if (this.db) return this.db;

        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onerror = () => reject(request.error);

            request.onsuccess = () => {
                this.db = request.result;
                resolve(this.db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName, { keyPath: 'key' });
                }
            };
        });
    }

    static async load(key, fallback = {}) {
        try {
            const db = await this.initDB();
            const transaction = db.transaction([this.storeName], 'readonly');
            const store = transaction.objectStore(this.storeName);
            const request = store.get(key);

            return new Promise((resolve) => {
                request.onsuccess = () => {
                    const result = request.result;
                    resolve(result?.value !== undefined ? result.value : fallback);
                };
                request.onerror = () => resolve(fallback);
            });
        } catch {
            return fallback;
        }
    }

    static async save(key, value) {
        try {
            const db = await this.initDB();
            const transaction = db.transaction([this.storeName], 'readwrite');
            const store = transaction.objectStore(this.storeName);
            store.put({ key, value });

            return new Promise((resolve, reject) => {
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            });
        } catch (error) {
            console.error('Failed to save to IndexedDB:', error);
        }
    }
}

async function getDeletedPersonalTags() {
    return await Storage.load(KEYS.DELETED_PERSONAL_TAGS, {});
}

async function saveDeletedPersonalTags(deleted) {
    await Storage.save(KEYS.DELETED_PERSONAL_TAGS, deleted);
}

async function getDeletedTagLookup() {
    return await Storage.load(KEYS.DELETED_TAG_LOOKUP, {});
}

async function saveDeletedTagLookup(deleted) {
    await Storage.save(KEYS.DELETED_TAG_LOOKUP, deleted);
}

  function isValidWorkId(id) {
        if (!id || typeof id !== "string") return false;
        if (id.indexOf('null') !== -1 || id.indexOf('undefined') !== -1 || id.indexOf('NaN') !== -1) return false;
        if (id.trim() === '' || id.length > 8) return false;
        return /^\d+$/.test(id);
    }

    // Storage functions
async function getPersonalTags(workId) {
    const tags = await Storage.load(KEYS.PERSONAL_TAGS, {});
    return tags[workId] || [];
}

async function savePersonalTags(workId, tags) {
    if (!isValidWorkId(workId)) return;
    const allTags = await Storage.load(KEYS.PERSONAL_TAGS, {});
    allTags[workId] = tags;
    await Storage.save(KEYS.PERSONAL_TAGS, allTags);
}

async function getTagLookup() {
    return await Storage.load(KEYS.TAG_LOOKUP, {});
}

async function saveTagLookup(tagLookup) {
    await Storage.save(KEYS.TAG_LOOKUP, tagLookup);
}

async function getTagLinks() {
    return await Storage.load(KEYS.TAG_LINKS, {});
}

async function saveTagLinks(tagLinks) {
    await Storage.save(KEYS.TAG_LINKS, tagLinks);
}

async function getTagLink(tag) {
    var normalizedTag = normalizeTag(tag);
    var tagLinks = await getTagLinks();
    return tagLinks[normalizedTag] || 'https://archiveofourown.org/tags/' + encodeURIComponent(tag) + '/works';
}

async function setTagLink(tag, link) {
    var normalizedTag = normalizeTag(tag);
    var tagLinks = await getTagLinks();
    tagLinks[normalizedTag] = link;
    await saveTagLinks(tagLinks);
}

    function normalizeTag(tag) {
        return tag.toLowerCase().trim();
    }

    function capitalizeTag(tag) {
        return tag.split(' ').map(function(word) {
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }).join(' ');
    }

async function addWorkToTag(tag, workInfo) {
    var normalizedTag = normalizeTag(tag);
    var tagLookup = await getTagLookup();
    if (!tagLookup[normalizedTag]) {
        tagLookup[normalizedTag] = {};
    }
    tagLookup[normalizedTag][workInfo.id] = {
        title: workInfo.title,
        author: workInfo.author,
        summary: workInfo.summary || ''
    };
    await saveTagLookup(tagLookup);
}

async function removeWorkFromTag(tag, workId) {
    var normalizedTag = normalizeTag(tag);
    var tagLookup = await getTagLookup();
    if (tagLookup[normalizedTag]) {
        delete tagLookup[normalizedTag][workId];
        if (Object.keys(tagLookup[normalizedTag]).length === 0) {
            delete tagLookup[normalizedTag];
        }
        await saveTagLookup(tagLookup);
    }
}

    function getWorkInfo() {
        var match = window.location.pathname.match(/\/works\/(\d+)/);
        var workId = match ? match[1] : null;
        if (!workId || !isValidWorkId(workId)) return null;

        var titleElement = document.querySelector('.title.heading');
        var title = titleElement ? titleElement.textContent.trim() : '';

        var authorElement = document.querySelector('.byline.heading a[rel="author"]');
        var author = authorElement ? authorElement.textContent.trim() : '';

        var summaryElement = document.querySelector('.summary blockquote');
        var summary = summaryElement ? summaryElement.textContent.trim() : '';

        return { id: workId, title: title, author: author, summary: summary };
    }

    function showLinkEditor(tag, callback) {
        var existingModal = document.querySelector('#link-editor-modal');
        if (existingModal) existingModal.remove();

        var overlay = document.createElement('div');
        overlay.id = 'link-editor-modal';
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 9999;';

        var modal = document.createElement('div');
        modal.style.cssText = 'background: #232136CC; color: #FFF; padding: 20px; border: 1.5px solid #ddd; border-radius: 6px; max-width: 500px; width: 90%; box-shadow: 0 0 10px rgba(0,0,0,0.5); font-family: sans-serif;';

        modal.addEventListener('click', function(e) {
            e.stopPropagation();
        });

        var header = document.createElement('h3');
        header.style.cssText = 'margin: 0 0 15px 0; font-size: 1.1em;';
        header.textContent = 'Edit Link for "' + tag + '"';
        modal.appendChild(header);

// CORRECT CODE:
var input = document.createElement('input');
input.type = 'url';
getTagLink(tag).then(link => input.value = link);  // Set input value, not tagEl.href
input.placeholder = 'Enter URL...';
        input.style.cssText = 'width: 100%; padding: 8px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 3px; background: #2A273F; color: #FFF; box-sizing: border-box;';
        modal.appendChild(input);

        var buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';
        modal.appendChild(buttonsContainer);

        var saveButton = document.createElement('button');
        saveButton.textContent = 'Save';
        saveButton.style.cssText = 'padding: 6px 12px; border: none; border-radius: 3px; background: #46446C; color: #FFF; cursor: pointer;';
        saveButton.addEventListener('click', async function() {
            var newLink = input.value.trim();
            if (newLink) {
                await setTagLink(tag, newLink);
                if (callback) callback();
            }
            overlay.remove();
        });
        buttonsContainer.appendChild(saveButton);

        var cancelButton = document.createElement('button');
        cancelButton.textContent = 'Cancel';
        cancelButton.style.cssText = 'padding: 6px 12px; border: 1px solid #999; border-radius: 3px; background: transparent; color: #FFF; cursor: pointer;';
        cancelButton.addEventListener('click', function() {
            overlay.remove();
        });
        buttonsContainer.appendChild(cancelButton);

        var resetButton = document.createElement('button');
        resetButton.textContent = 'Reset to Default';
        resetButton.style.cssText = 'padding: 6px 12px; border: 1px solid #999; border-radius: 3px; background: transparent; color: #FFF; cursor: pointer;';
        resetButton.addEventListener('click', function() {
            var defaultLink = 'https://archiveofourown.org/tags/' + encodeURIComponent(tag) + '/works';
            input.value = defaultLink;
        });
        buttonsContainer.appendChild(resetButton);

        overlay.appendChild(modal);

        overlay.addEventListener('click', function() {
            overlay.remove();
        });

        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' || e.keyCode === 13) {
                saveButton.click();
            }
        });

        document.body.appendChild(overlay);
        input.focus();
        input.select();
    }

    // Helper: get all used tags
async function getAllUsedTags() {
    const allTags = await Storage.load(KEYS.PERSONAL_TAGS, {});
    const tagsSet = new Set();
    Object.values(allTags).forEach(workTags => workTags.forEach(tag => tagsSet.add(tag)));
    return Array.from(tagsSet).sort();
}

async function addTagsToWorkPage() {
    const workInfo = getWorkInfo();
    if (!workInfo) return;

    // Find the work meta section
    const workMeta = document.querySelector('dl.work.meta.group');
    if (!workMeta) return;

    // Check if we already added personal tags
    if (document.querySelector('.personal-tags-meta')) return;

    // Create the Personal Tags section with native AO3 styling
    const dtElement = document.createElement('dt');
    dtElement.className = 'freeform tags personal-tags-meta';
    dtElement.textContent = 'Personal Tags:';

    const ddElement = document.createElement('dd');
    ddElement.className = 'freeform tags personal-tags-meta';

    // Create the tags container (ul.commas like native AO3)
    const tagsContainer = document.createElement('ul');
    tagsContainer.className = 'commas';
    tagsContainer.style.cssText = 'position: relative;';

    // Input container for adding tags (initially hidden)
    const inputContainer = document.createElement('div');
    inputContainer.style.cssText = `
        position: absolute;
        top: 100%;
        left: 0;
        width: 300px;
        background: #2a273f;
        border: 1px solid;
        border-radius: 3px;
        padding: 10px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        z-index: 1000;
        display: none;
    `;

    const tagInput = document.createElement('input');
    tagInput.type = 'text';
    tagInput.placeholder = 'Add tag...';
    tagInput.style.cssText = `
        width: 100%;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 3px;
        margin-bottom: 5px;
        box-sizing: border-box;
    `;

    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = 'display: flex; gap: 5px; justify-content: flex-end;';

    const addButton = document.createElement('button');
    addButton.textContent = 'Add';
    addButton.style.cssText = `
        padding: 4px 8px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 0.9em;
    `;

    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.style.cssText = `
        padding: 4px 8px;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 0.9em;
    `;

    // Suggestion box
    const suggestionBox = document.createElement('div');
    suggestionBox.style.cssText = `
    position: absolute;
    background: #2A273F;
    border: 1px solid #ccc;
    max-height: 150px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
    min-width: 300px;
`;

    buttonContainer.appendChild(addButton);
    buttonContainer.appendChild(cancelButton);
    inputContainer.appendChild(tagInput);
    inputContainer.appendChild(buttonContainer);

    tagsContainer.appendChild(inputContainer);

    document.body.appendChild(suggestionBox);


    // Function to render tags in native AO3 style
    async function renderTags() {
        const tags = await getPersonalTags(workInfo.id);

        // Clear existing tags (but keep input container)
        const existingItems = tagsContainer.querySelectorAll('li:not(.input-container)');
        existingItems.forEach(item => item.remove());

        if (tags.length === 0) {
            // Show just the plus button when no tags
            const li = document.createElement('li');
            const addBtn = document.createElement('button');
            addBtn.innerHTML = '<b>+</b>';
            addBtn.style.cssText = `
                border: 1px solid #3a3451;
                border-radius: 3px;
                cursor: pointer;
                padding: 2px 6px;
                font-size: 14px;
            `;
            addBtn.addEventListener('click', showAddTagInput);
            li.appendChild(addBtn);
            tagsContainer.insertBefore(li, inputContainer);
        } else {
            // Show existing tags in native style
            tags.forEach((tag, index) => {
                const li = document.createElement('li');

                const tagLink = document.createElement('a');
                tagLink.className = 'tag';
                tagLink.href = `/tags/${encodeURIComponent(tag)}/works`;
                tagLink.textContent = tag;
                tagLink.style.cssText = `
                    text-decoration: none;
                    padding: 2px 8px;
                    font-size: 0.9em;
                    display: inline-flex;
                    align-items: center;
                    gap: 4px;
                `;

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = '×';
removeBtn.style.cssText = `
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  outline: none !important;
  color: #666;
  cursor: pointer;
  font-weight: bold;
  padding: 0;
  margin-left: 6px;
  line-height: 1;
  display: inline-block;
  box-sizing: border-box;
  transform: scale(1.5);
  transform-origin: center;
`;

              // Hover effect: enlarge without affecting container
removeBtn.addEventListener('mouseenter', () => {
    removeBtn.style.color = '#fff';
});
removeBtn.addEventListener('mouseleave', () => {
    removeBtn.style.color = '#666';
});


                removeBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const currentTags = await getPersonalTags(workInfo.id);
                    const newTags = currentTags.filter(t => t !== tag);
                    await savePersonalTags(workInfo.id, newTags);
                    await removeWorkFromTag(tag, workInfo.id);
                    await renderTags();
                });

                tagLink.appendChild(removeBtn);
                li.appendChild(tagLink);
                tagsContainer.insertBefore(li, inputContainer);
            });

            // Add the plus button after existing tags
            const li = document.createElement('li');
            const addBtn = document.createElement('button');
            addBtn.innerHTML = '<b>+</b>';
            addBtn.style.cssText = `
                border: 1px solid #3a3451;
                border-radius: 3px;
                cursor: pointer;
                padding: 2px 6px;
                font-size: 14px;
                margin-left: 0.5em;
            `;
            addBtn.addEventListener('click', showAddTagInput);
            li.appendChild(addBtn);
            tagsContainer.insertBefore(li, inputContainer);
        }
    }


    // Function to show add tag input
function showAddTagInput(e) {
    // If called as an event handler, e.currentTarget is the button clicked.
    // Otherwise, fall back to the first + button found inside tagsContainer.
    const clickedBtn = (e && e.currentTarget) || tagsContainer.querySelector('li button');

    // If no button found, just show the inputContainer in its default place
    if (!clickedBtn) {
        inputContainer.style.display = 'block';
        tagInput.focus();
        setupInputHandlers();
        return;
    }

    // Ensure inputContainer is absolutely positioned relative to tagsContainer
    // (tagsContainer already has `position: relative;` in your code)
    inputContainer.style.position = 'absolute';

    // Use offsetLeft/offsetTop so the popup aligns with the clicked + button
    // These are relative to the offsetParent (tagsContainer), which is what we want.
    const left = clickedBtn.offsetLeft;
    const top = clickedBtn.offsetTop + clickedBtn.offsetHeight;

    inputContainer.style.left = left + 'px';
    inputContainer.style.top  = top + 'px';
    inputContainer.style.display = 'block';

    // focus and wire up handlers
    tagInput.focus();
    setupInputHandlers();
}


    // Function to hide add tag input
    function hideAddTagInput() {
        inputContainer.style.display = 'none';
        suggestionBox.style.display = 'none';
        tagInput.value = '';
    }

    // Setup input handlers
    let selectedIndex = -1;

    function setupInputHandlers() {
        // Clear previous handlers to prevent duplicates
        tagInput.onkeypress = null;
        tagInput.onkeydown = null;
        tagInput.oninput = null;

        // Add tag functionality
        const addTag = async () => {
            const newTag = tagInput.value.trim();
            if (!newTag) return;

            const currentTags = await getPersonalTags(workInfo.id);
            if (!currentTags.includes(newTag)) {
                currentTags.push(newTag);
                await savePersonalTags(workInfo.id, currentTags);
                await addWorkToTag(newTag, workInfo);
            }

            hideAddTagInput();
            await renderTags();
        };

        addButton.onclick = addTag;
        cancelButton.onclick = hideAddTagInput;

        // Enter key handling
        tagInput.onkeypress = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0) {
                    const suggestions = suggestionBox.querySelectorAll('.suggestion-item');
                    if (suggestions[selectedIndex]) {
                        suggestions[selectedIndex].click();
                    }
                } else {
                    addTag();
                }
            }
        };

        // Escape key handling
        tagInput.onkeydown = (e) => {
            const suggestions = suggestionBox.querySelectorAll('.suggestion-item');

            switch(e.key) {
                case 'Escape':
                    hideAddTagInput();
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, suggestions.length - 1);
                    updateSuggestionSelection(suggestions);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSuggestionSelection(suggestions);
                    break;
            }
        };

        // Autocomplete suggestions
        tagInput.oninput = async () => {
            const query = tagInput.value.toLowerCase();
            if (!query) {
                suggestionBox.style.display = 'none';
                return;
            }

          const allUsedTags = await getAllUsedTags();
    console.log('All used tags:', allUsedTags); // Debug line

            const usedTags = (await getAllUsedTags()).filter(t =>
                t.toLowerCase().includes(query) && t.toLowerCase() !== query
            );
              console.log('Filtered tags:', usedTags); // Debug line

            selectedIndex = -1;

if (usedTags.length) {
    const inputRect = tagInput.getBoundingClientRect();
    suggestionBox.style.top = (inputRect.bottom + window.scrollY) + 'px';
    suggestionBox.style.left = inputRect.left + 'px';
    suggestionBox.innerHTML = '';

    console.log('Suggestion box position:', suggestionBox.style.top, suggestionBox.style.left); // Debug line
    console.log('Suggestion box display:', suggestionBox.style.display); // Debug line


    usedTags.forEach((tag, index) => {
        const item = document.createElement('div');
        item.textContent = tag;
        item.className = 'suggestion-item';
        item.dataset.index = index;
        item.style.cssText = 'padding: 5px 10px; cursor: pointer; font-size: 16px;';
        item.addEventListener('mouseenter', () => {
            selectedIndex = index;
            updateSuggestionSelection(suggestionBox.querySelectorAll('.suggestion-item'));
        });
        item.addEventListener('click', async () => {
            const currentTags = await getPersonalTags(workInfo.id);
            if (!currentTags.includes(tag)) {
                currentTags.push(tag);
                await savePersonalTags(workInfo.id, currentTags);
                await addWorkToTag(tag, workInfo);
            }
            hideAddTagInput();
            await renderTags();
        });
        suggestionBox.appendChild(item);
    });
suggestionBox.style.display = 'block';
  console.log('Should be showing suggestions now'); // Debug line

} else {
    suggestionBox.style.display = 'none';
}
        };
    }

    function updateSuggestionSelection(suggestions) {
        suggestions.forEach((item, index) => {
            if (index === selectedIndex) {
                item.style.background = '#f0f0f0';
            } else {
                item.style.background = 'transparent';
            }
        });
    }

    ddElement.appendChild(tagsContainer);

    // Insert after Additional Tags or before Stats
    const additionalTagsDD = workMeta.querySelector('dd.freeform.tags');
    if (additionalTagsDD) {
        // Insert after Additional Tags
        const additionalTagsDT = additionalTagsDD.previousElementSibling;
        additionalTagsDD.parentNode.insertBefore(dtElement, additionalTagsDD.nextSibling);
        dtElement.parentNode.insertBefore(ddElement, dtElement.nextSibling);
    } else {
        // Insert before Stats
        const statsDD = workMeta.querySelector('dd.stats');
        if (statsDD) {
            const statsDT = statsDD.previousElementSibling;
            statsDT.parentNode.insertBefore(dtElement, statsDT);
            dtElement.parentNode.insertBefore(ddElement, statsDT);
        } else {
            // Just append to the end
            workMeta.appendChild(dtElement);
            workMeta.appendChild(ddElement);
        }
    }

    // Initial render
    await renderTags();

    // Close input when clicking outside
    document.addEventListener('click', (e) => {
        if (!inputContainer.contains(e.target) && !tagsContainer.contains(e.target)) {
            hideAddTagInput();
        }
    });
}

async function addPersonalTagsToSearchResults() {
    console.log('Function running...');

    // Find all work blurbs on search/listing pages
    const workBlurbs = document.querySelectorAll('li.work.blurb.group');
    console.log('Found blurbs:', workBlurbs.length);

    if (!workBlurbs.length) return;

    for (const blurb of workBlurbs) {
        console.log('Processing blurb...');

        // Skip if we already added personal tags to this blurb
        if (blurb.querySelector('.personal-tags-search')) {
            console.log('Already has personal tags, skipping');
            continue;
        }

        // Extract work ID from the blurb
        const workLink = blurb.querySelector('h4.heading a[href*="/works/"]');
        console.log('Found work link:', workLink ? workLink.href : 'none');
        if (!workLink) continue;

        const match = workLink.href.match(/\/works\/(\d+)/);
        console.log('Work ID match:', match);
        if (!match) continue;

        const workId = match[1];
        console.log('Work ID:', workId);

        // Get personal tags for this work
        const personalTags = await getPersonalTags(workId);
        console.log('Personal tags for work', workId, ':', personalTags);
        if (!personalTags.length) continue;

        // Find the existing tags ul to insert after it
        const existingTagsUL = blurb.querySelector('ul.tags');
        if (!existingTagsUL) continue;

        // Create a new ul for personal tags
        const personalTagsUL = document.createElement('ul');
        personalTagsUL.className = 'tags commas personal-tags-search';
        personalTagsUL.style.cssText = `
            margin: 4px 0 0 0;
            padding-left: 0;
            list-style: none;
        `;

        // Add a label
        const labelLi = document.createElement('li');
        labelLi.style.cssText = `
            display: inline;
            color: #ccc;
            font-style: italic;
            margin-right: 0.5em;
        `;
        labelLi.textContent = 'Personal tags:';
        personalTagsUL.appendChild(labelLi);

        // Add each personal tag
        personalTags.forEach((tag, index) => {
            const li = document.createElement('li');
            li.style.display = 'inline';

            const tagLink = document.createElement('a');
            tagLink.className = 'tag';
            tagLink.textContent = tag;


            // Set the link to use custom URL if available, otherwise default
            getTagLink(tag).then(href => {
                tagLink.href = href;
            });

            li.appendChild(tagLink);

            personalTagsUL.appendChild(li);
        });

        // Insert the personal tags after the existing tags
        existingTagsUL.parentNode.insertBefore(personalTagsUL, existingTagsUL.nextSibling);
    }
}

async function addPersonalWorksToTagPage() {
  try {
            var currentUrl = window.location.href;
            var match = window.location.pathname.match(/\/tags\/([^\/]+)/);
            var currentTag = match ? decodeURIComponent(match[1]) : '';
            if (!currentTag) return;

var tagLookup = await getTagLookup();
var tagLinks = await getTagLinks();

            console.log('Current URL:', currentUrl);
            console.log('Current tag:', currentTag);

            // Find all tags that should be displayed on this page
            var tagsToShow = [];

            // Check if this is a direct tag match
            var normalizedCurrentTag = normalizeTag(currentTag.replace(/%20/g, ' ').replace(/_/g, ' '));
            if (tagLookup[normalizedCurrentTag]) {
                var defaultLink = 'https://archiveofourown.org/tags/' + encodeURIComponent(currentTag.replace(/%20/g, ' ').replace(/_/g, ' ')) + '/works';
                var tagHasCustomLink = tagLinks[normalizedCurrentTag] && tagLinks[normalizedCurrentTag] !== defaultLink;

                tagsToShow.push({
                    normalizedTag: normalizedCurrentTag,
                    displayName: capitalizeTag(currentTag.replace(/%20/g, ' ').replace(/_/g, ' ')),
                    works: tagLookup[normalizedCurrentTag],
                    hasCustomLink: tagHasCustomLink,
                    isDirect: true
                });
            }

            // Check for tags with custom links pointing to this page
            for (var normalizedTag in tagLinks) {
                var customLink = tagLinks[normalizedTag];

                var urlsMatch = customLink === currentUrl ||
                               customLink === window.location.href ||
                               customLink === (window.location.protocol + '//' + window.location.host + window.location.pathname + window.location.search) ||
                               customLink === (window.location.protocol + '//' + window.location.host + window.location.pathname);

                if (urlsMatch && tagLookup[normalizedTag]) {
                    // Check if we already added this tag
                    var alreadyAdded = false;
                    for (var i = 0; i < tagsToShow.length; i++) {
                        if (tagsToShow[i].normalizedTag === normalizedTag) {
                            alreadyAdded = true;
                            break;
                        }
                    }

                    if (!alreadyAdded) {
                        var works = tagLookup[normalizedTag];
                        var displayName = capitalizeTag(normalizedTag);

                        tagsToShow.push({
                            normalizedTag: normalizedTag,
                            displayName: displayName,
                            works: works,
                            hasCustomLink: true,
                            isDirect: false
                        });
                    }
                }
            }

            console.log('Tags to show:', tagsToShow);

            if (tagsToShow.length === 0) {
                console.log('No tags to show');
                return;
            }

            // Wait for page to load, then insert our content
            setTimeout(function() {
                // Find the works list
                var worksList = document.querySelector('ol.work.index.group') ||
                               document.querySelector('#main ol.index.group') ||
                               document.querySelector('#main .index.group') ||
                               document.querySelector('ol.work.index');

                if (!worksList) {
                    console.log('Works list not found');
                    return;
                }

                // Remove existing personal tags section if it exists
                var existingSection = document.querySelector('#personal-tags-section');
                if (existingSection) {
                    existingSection.remove();
                }

                // Create main container for all personal tag sections
                var mainContainer = document.createElement('div');
                mainContainer.id = 'personal-tags-section';
                mainContainer.style.cssText = 'margin: 15px 0;';

                // Create each tag section
                for (var i = 0; i < tagsToShow.length; i++) {
    var tagInfo = tagsToShow[i];
    var works = tagInfo.works;
    var workIds = Object.keys(works);

    if (workIds.length === 0) {
        continue;
    }


                    // Create section container - using simpler styling
                    var section = document.createElement('div');
                    section.style.cssText = 'margin: 0 0 15px 0; padding: 5px; border: 1px solid; border-radius: 5px; overflow: hidden;';

                    // Create section header
                    var header = document.createElement('h4');
                    header.style.cssText = 'margin: 0; padding: 10px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;';

                    var headerText = document.createElement('span');
                    headerText.textContent = '📌 Your Personal "' + tagInfo.displayName + '" Tags';


                    var toggleIndicator = document.createElement('span');
                    toggleIndicator.textContent = '▼';
                    toggleIndicator.style.cssText = 'font-size: 0.8em; transition: transform 0.2s; transform: rotate(-90deg);';

                    header.appendChild(headerText);
                    header.appendChild(toggleIndicator);

                    // Create content container (initially collapsed)
                    var content = document.createElement('div');
                    content.style.cssText = 'padding: 0 10px; max-height: 0; overflow: hidden; transition: max-height 0.3s ease, padding 0.3s ease;';

                    // Create works list
                    var worksContainer = document.createElement('div');
                    worksContainer.style.cssText = 'margin: 15px 0;';

                    for (var j = 0; j < workIds.length; j++) {
    var workId = workIds[j];
    var work = works[workId];

    var workItem = document.createElement('div');
    workItem.style.cssText = 'margin: 10px 0; padding: 8px; border-left: 3px solid;background: #2A273F; border-radius: 4px;';

    workItem.innerHTML = '<h4 style="margin: 0 0 5px 0;"><a href="/works/' + workId + '">' + (work.title || 'Untitled Work') + '</a></h4>' +
        '<p style="margin: 0; color: #999; font-size: 0.9em;">by ' + (work.author && work.author.trim() ? work.author : 'Anonymous') + '</p>' +
        (work.summary && work.summary.trim() ? '<p style="margin: 5px 0 0 0; font-size: 0.85em;">' + (work.summary.length > 250 ? work.summary.substring(0, 250) + '...' : work.summary) + '</p>' : '');

    worksContainer.appendChild(workItem);
}
                  content.appendChild(worksContainer);

                    // Set up toggle functionality
                    var isExpanded = false;
                    (function(contentEl, indicator) {
                        header.addEventListener('click', function() {
                            if (isExpanded) {
                                contentEl.style.maxHeight = '0';
                                contentEl.style.padding = '0 10px';
                                indicator.style.transform = 'rotate(-90deg)';
                                isExpanded = false;
                            } else {
                                contentEl.style.maxHeight = contentEl.scrollHeight + 'px';
                                contentEl.style.padding = '15px';
                                indicator.style.transform = 'rotate(0deg)';
                                isExpanded = true;
                            }
                        });
                    })(content, toggleIndicator);

                    // Assemble the section
                    section.appendChild(header);
                    section.appendChild(content);
                    mainContainer.appendChild(section);
                }

                // Insert the main container before the works list
                try {
                    var parentElement = worksList.parentElement;
                    if (parentElement) {
                        parentElement.insertBefore(mainContainer, worksList);
                        console.log('Personal tags sections inserted successfully');
                    } else {
                        console.log('Could not find parent element for works list');
                    }
                } catch (error) {
                    console.error('Error inserting personal tags sections:', error);
                    // Fallback: try to append to a common container
                    var mainContent = document.querySelector('#main') || document.querySelector('.content');
                    if (mainContent) {
                        mainContent.insertBefore(mainContainer, mainContent.firstChild);
                    }
                }

            }, 500);

        } catch (error) {
            console.error('Error in addPersonalWorksToTagPage:', error);
        }
    }

async function showPersonalTagsModal() {
  var allTags = await Storage.load(KEYS.PERSONAL_TAGS, {});
        var tagsArray = [];

var tagCounts = {};
for (var workId in allTags) {
    var workTags = allTags[workId];
    for (var i = 0; i < workTags.length; i++) {
        var tag = workTags[i];
        if (tagsArray.indexOf(tag) === -1) {
            tagsArray.push(tag);
        }
        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
    }
}
var sortedTags = tagsArray.sort();

        if (sortedTags.length === 0) {
            alert('No personal tags found.');
            return;
        }

        var existingModal = document.querySelector('#personal-tags-modal');
        if (existingModal) existingModal.remove();

        var overlay = document.createElement('div');
        overlay.id = 'personal-tags-modal';
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 9999;';

        overlay.addEventListener('click', function() {
            overlay.remove();
        });

        var modal = document.createElement('div');
        modal.style.cssText = 'background: #232136CC; color: #FFF; padding: 20px; border: 1.5px solid #ddd; border-radius: 6px; max-width: 600px; width: 90%; max-height: 80%; overflow-y: auto; box-shadow: 0 0 10px rgba(0,0,0,0.5); position: relative; font-family: sans-serif;';

        modal.addEventListener('click', function(e) {
            e.stopPropagation();
        });

        overlay.appendChild(modal);

var header = document.createElement('div');
header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; font-weight: bold; font-size: 1.2em; margin-bottom: 15px; border-bottom: 1px solid #ddd; padding-bottom: 8px;';

var headerText = document.createElement('span');
headerText.textContent = '📌 Your Personal Tags';
header.appendChild(headerText);

// Add cleanup button
var cleanupButton = document.createElement('button');
cleanupButton.textContent = 'Cleanup Empty Tags';
cleanupButton.style.cssText = 'border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8em;';
cleanupButton.addEventListener('click', async function() {
    console.log('Button clicked!');
    var result = await cleanupEmptyTags();
    if (result) {
        alert('Cleanup complete!');
        overlay.remove();
        showPersonalTagsModal();
    } else {
        alert('No cleanup needed.');
    }
});

header.appendChild(cleanupButton);
modal.appendChild(header);

        var content = document.createElement('div');
        content.style.cssText = 'display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px;';

for (var i = 0; i < sortedTags.length; i++) {
    var tag = sortedTags[i];
    var tagContainer = document.createElement('div');
    tagContainer.style.cssText = 'display: inline-flex; align-items: center; padding: 4px 8px; background: #44415a40; border-radius: 4px; gap: 6px; transition: background-color 0.2s;';

var tagEl = document.createElement('a');
    tagEl.textContent = tag + ' (' + tagCounts[tag] + ')';

    // Use IIFE to handle async operation
    (async function(element, tagName) {
        element.href = await getTagLink(tagName);
    })(tagEl, tag);
    tagEl.target = '_blank';
    tagEl.style.cssText = 'cursor: pointer; font-size: 0.95em; text-decoration: none; color: inherit; transition: color 0.2s;';


            var editButton = document.createElement('button');
            editButton.innerHTML = '⚙️';
            editButton.title = 'Edit custom link for "' + tag + '"';
            editButton.style.cssText = 'background: none; border: none; color: #bbb; cursor: pointer; font-size: 12px; padding: 2px; line-height: 1; transition: all 0.2s;';

            editButton.addEventListener('mouseenter', function() {
                this.style.color = '#fff';
                this.style.transform = 'scale(1.1)';
            });

            editButton.addEventListener('mouseleave', function() {
                this.style.color = '#bbb';
                this.style.transform = 'scale(1)';
            });

            (function(tagName, linkElement) {
                editButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    showLinkEditor(tagName, async function() {
                        linkElement.href = await getTagLink(tagName);
                    });
                });
            })(tag, tagEl);

            tagContainer.appendChild(tagEl);
            tagContainer.appendChild(editButton);

            tagContainer.addEventListener('mouseenter', function() {
                this.style.backgroundColor = '#232136CC';
            });

            tagContainer.addEventListener('mouseleave', function() {
                this.style.backgroundColor = '#44415a40';
            });

            content.appendChild(tagContainer);
        }
        modal.appendChild(content);

        document.body.appendChild(overlay);
    }

    function addPersonalTagsButton() {
        var nav = document.querySelector("ul.primary.navigation.actions") ||
                 document.querySelector("ul.primary.navigation") ||
                 document.querySelector("nav ul");

        if (!nav) return;
        if (document.querySelector("#personal-tags-btn")) return;

        var personalTagsLi = document.createElement("li");
        personalTagsLi.innerHTML = '<a href="#" id="personal-tags-btn">Personal Tags</a>';
        nav.appendChild(personalTagsLi);

        personalTagsLi.querySelector("a").addEventListener("click", function(e) {
            e.preventDefault();
            showPersonalTagsModal();
        });
    }

async function cleanupEmptyTags() {
      console.log('cleanupEmptyTags function started');

var personalTags = await Storage.load(KEYS.PERSONAL_TAGS, {});
var tagLookup = await Storage.load(KEYS.TAG_LOOKUP, {});
    var cleaned = false;

// Remove works with empty tag arrays from personal tags
for (var workId in personalTags) {
    console.log('Checking work:', workId, 'tags:', personalTags[workId], 'length:', personalTags[workId] ? personalTags[workId].length : 'undefined');
    if (!personalTags[workId] || personalTags[workId].length === 0) {
        delete personalTags[workId];

        // Track this deletion for sync
        var deletedPersonalTags = await getDeletedPersonalTags();
        deletedPersonalTags[workId + '_cleanup'] = Date.now();
        await saveDeletedPersonalTags(deletedPersonalTags);

        cleaned = true;
        console.log('Removed empty personal tags for work:', workId);
    }
}

// Remove empty tag categories from tag lookup
for (var tagName in tagLookup) {
    if (!tagLookup[tagName] || Object.keys(tagLookup[tagName]).length === 0) {
        delete tagLookup[tagName];

        // Track this deletion for sync
        var deletedTagLookup = await getDeletedTagLookup();
        deletedTagLookup[tagName + '_cleanup'] = Date.now();
        await saveDeletedTagLookup(deletedTagLookup);

        cleaned = true;
        console.log('Removed empty tag lookup for:', tagName);
    }
}

// Check for orphaned tag lookup entries
console.log('Checking for orphaned entries...');
for (var tagName in tagLookup) {
    var works = tagLookup[tagName];
    console.log('Checking tag:', tagName, 'with works:', Object.keys(works));
    for (var workId in works) {
        var workPersonalTags = personalTags[workId] || [];
        console.log('Work', workId, 'personal tags:', workPersonalTags);
        var hasThisTag = false;
        for (var i = 0; i < workPersonalTags.length; i++) {
            if (normalizeTag(workPersonalTags[i]) === tagName) {
                hasThisTag = true;
                break;
            }
        }
        console.log('Work', workId, 'has tag', tagName, '?', hasThisTag);
        if (!hasThisTag) {
            delete works[workId];
            cleaned = true;
            console.log('Removed orphaned work from tag lookup:', workId, 'from tag:', tagName);
        }
    }
}

// Always save if anything was cleaned
if (cleaned) {
await Storage.save(KEYS.PERSONAL_TAGS, personalTags);
await Storage.save(KEYS.TAG_LOOKUP, tagLookup);
    console.log('Cleanup complete');
}

// Always return true so the button logic runs
return cleaned;
}

async function init() {
    await Storage.initDB();
    var path = window.location.pathname;

    if (path.match(/\/works\/\d+/)) {
        addTagsToWorkPage();
} else if (path.match(/\/tags\/[^\/]+\/works/)) {
    addPersonalWorksToTagPage();
    // Also add personal tags to individual work blurbs on tag pages
    setTimeout(addPersonalTagsToSearchResults, 500);

    const observer = new MutationObserver(() => {
        setTimeout(addPersonalTagsToSearchResults, 100);
    });

    const targetNode = document.querySelector('#main') || document.body;
    observer.observe(targetNode, {
        childList: true,
        subtree: true
    });
} else if (
        path.includes('/works') ||
        path.includes('/search') ||
        path.includes('/bookmarks') ||
        path.includes('/series/') ||
        path.includes('/collections/') ||
        path.includes('/users/')
    ) {
        // Add personal tags to search results and listing pages
        // Use a timeout to ensure the page content has loaded
        setTimeout(addPersonalTagsToSearchResults, 500);

        // Also add observer for infinite scroll or dynamic content
        const observer = new MutationObserver(() => {
            setTimeout(addPersonalTagsToSearchResults, 100);
        });

        const targetNode = document.querySelector('#main') || document.body;
        observer.observe(targetNode, {
            childList: true,
            subtree: true
        });
    }

    addPersonalTagsButton();
}

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

})();

